<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[03-ActiveMQ高级讲解]]></title>
    <url>%2F2020%2F07%2F15%2F2020-07-14-03-ActiveMQ%E9%AB%98%E7%BA%A7%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ActiveMQ高级讲解 ActiveMQ消息组成与高级特性JMS消息组成详解整个JMS协议组成结构如下 结构 描述 JMS Provider 消息中间件/消息服务器 JMS Producer 消息生产者 JMS Consumer 消息消费者 JMS Message 消息（重要） 重点讲解JMS Message，其有三部分组成： 消息头 消息体 消息属性 JMS消息头JMS消息头预定义了若干字段用于客户端与JMS提供者之间识别和发送消息，预编译如下： 其中标黑的为重要的消息头 名称 描述 MessageID 唯一标识提供者发送的每一条消息，这个字段由提供者设置，不能修改。客户机只有在接收到消息后才能确实消息的Message ID Destination 消息发送的队列方式和队列名称，在发送过程中由提供者设置 CorrelationID 通常用于链接响应消息与请求消息，由消息的JMS程序（代码）设置 Timestamp 提供者发送信息的时间，有提供者在发送过程中设置 Reply To 请求程序用它来指出回复消息应发送的地方，由发送消息的JMS程序设置 Expiration 消息失效的时间，值0表明消息不会过期，默认0 DeliveryMode 消息持久化，包括DeliveryMode.NON_PERSISTENT和DeliveryMode.PERSISTENT Priority 消息的优先级。0-4表示普通消息，5-9表示加急消息。ActiveMQ不保证优先级高就一定先发送，只保证了加急消息必须先于普通消息发送。默认是4 Redelivered 消息的重发标志，false：代表消息是第一次发送。true：代表消息为重发消息 Type JMS程序用它来指出消息的类型 需要注意，在传送消息时，消息头的值有JMS提供者来设置，因此开发者使用以上setJMSXXX()方法分配的值会被忽略，即虽然设置了，但是无效。只有以下几个值可以由开发者设置 CorrelationID，Reply To，Type 发送方设置方式如下： 123456789101112131415@Testpublic void ptpSender2()&#123; jmsTemplate.send("springboot_queue2", new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage("springboot queue message2"); textMessage.setJMSCorrelationID("abcdefg"); textMessage.setJMSExpiration(3000); textMessage.setJMSDeliveryMode(DeliveryMode.NON_PERSISTENT); return textMessage; &#125; &#125;); System.out.println("消息发送成功");&#125; 接收方直接使用getJMSXXX()获取就行了 JMS消息体在消息体中，JMS有5中类型的消息格式，让我们可以以不同的形式发送和接收消息，并提供了已有消息格式的兼容，不同的消息类型如下： 12345TextMessage：一个字符串对象MapMessage：一套名称-键值对ObjectMessage：一个序列化的java对象BytesMessage：一个字节的数据流StreamMessage：Java原始值的数据流 TextMessage 发送： 12345678910public void ptpSender()&#123; jmsTemplate.send("springboot_queue", new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage("springboot queue message2"); return textMessage; &#125; &#125;);&#125; 接收： 1234567891011@JmsListener(destination = "springboot_queue")public void receiveMessage(Message message)&#123; if (message instanceof TextMessage)&#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println("接收到的消息："+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; MapMessage 发送： 1234567891011121314public void ptpSender()&#123; jmsTemplate.send("springboot_queue", new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; MapMessage mapMessage = session.createMapMessage(); //第一个是key，第二个是value mapMessage.setString("name","张三"); //第一个是key，第二个是value mapMessage.setInt("age",13); return mapMessage; &#125; &#125;);&#125; 接收： 123456789101112@JmsListener(destination = "springboot_queue")public void receiveMessage(Message message)&#123; if (message instanceof MapMessage)&#123; MapMessage mapMessage=(MapMessage) message; try &#123; System.out.println("接收到的消息："+mapMessage.getString("name")); System.out.println("接收到的消息："+mapMessage.getString("age")); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ObjectMessage 发送： 1234567891011121314public void ptpSender()&#123; jmsTemplate.send("springboot_queue", new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; User user=new User(); user.setName("李四"); user.setAge(14); //User对象必须实现序列化Serializable ObjectMessage objectMessage = session.createObjectMessage(user); return objectMessage; &#125; &#125;);&#125; 接收： 12345678910111213@JmsListener(destination = "springboot_queue")public void receiveMessage(Message message)&#123; if (message instanceof ObjectMessage)&#123; ObjectMessage objectMessage=(ObjectMessage) message; try &#123; User user=(User)objectMessage.getObject(); System.out.println("接收到的消息："+user.getName()); System.out.println("接收到的消息："+user.getAge()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意：此时启动会报以下错误 1javax.jms.JMSException: Failed to build body from content. Serializable class not available to broker. Reason: java.lang.ClassNotFoundException: Forbidden class com.hui.pojo.User! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes 原因是：ActiveMQ5.12后，为了安全考虑，ActiveMQ默认不接受自定义的序列化对象，需要将自定义的加入受信任的列表,即设置：spring.activemq.packages.trust-all=true 123456789# springboot与activemq整合配置spring.activemq.broker-url=tcp://192.168.25.181:61616spring.activemq.user=adminspring.activemq.password=admin# false表示不信任自定义的对象，true表示信任。默认为falsespring.activemq.packages.trust-all=true# 指定发送模式 false是点对点模式 true是发布/订阅模式spring.jms.pub-sub-domain=false BytesMessage 演示把一个图片的流发送到消息队列，然后从消息队列读取 发送： 123456789101112131415161718192021222324252627282930313233public void ptpSender()&#123; jmsTemplate.send("springboot_queue", new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; BytesMessage bytesMessage = session.createBytesMessage(); try &#123; /** * 整体流程： * 1.读取文件成流 * 2.创建一个空的字节数组，数组长度就是文件的字节长度 * 3.把文件流读入到字节数组中 * 4.把字节数组写入到bytesMessage中 */ //1.读取文件 File file=new File("src/main/resources/static/photo.png"); //2.构建文件文件流 FileInputStream fis=new FileInputStream(file); //3.把文件流写入到缓存数组中 byte[] buffer=new byte[(int)file.length()]; fis.read(buffer); //4.把缓存输入写入到bytesMessage中 bytesMessage.writeBytes(buffer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bytesMessage; &#125; &#125;);&#125; 接收： 12345678910111213141516171819202122232425@JmsListener(destination = "springboot_queue")public void receiveMessage(Message message)&#123; if (message instanceof BytesMessage)&#123; BytesMessage bytesMessage=(BytesMessage) message; try &#123; /** * 整体流程： * 1.创建一个空的字节数组，长度就是bytesMessage的长度 * 2.把bytesMessage读入到空的字节数组中 * 3.创建一个文件输出流，指定文件路径 * 4.把字节数组中的数据写入到文件输出流中 */ //1.设置缓存数组 byte[] buffer=new byte[(int)bytesMessage.getBodyLength()]; //2.把字节信息读入到缓存数组 bytesMessage.readBytes(buffer); //3.构建文件输出流 FileOutputStream fos=new FileOutputStream("src/main/resources/static/photocopy.png"); //4.把数据写出 fos.write(buffer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; StreamMessage 发送： 123456789101112public void ptpSender()&#123; jmsTemplate.send("springboot_queue", new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; StreamMessage streamMessage = session.createStreamMessage(); streamMessage.writeString("streamMessage演示"); streamMessage.writeInt(20); return streamMessage; &#125; &#125;);&#125; 接收： 123456789101112@JmsListener(destination = "springboot_queue")public void receiveMessage(Message message)&#123; if (message instanceof StreamMessage)&#123; StreamMessage streamMessage=(StreamMessage) message; try &#123; System.out.println("接收消息："+streamMessage.readString()); System.out.println("接收消息："+streamMessage.readInt()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; JMS消息属性 我们可以给消息设置自定义属性，这个属性只要是为了给消息打标记，用于实现消息的过滤功能 123XXXMessage.setXXXProperty("Property",Property);//例如：textMessage.setStringProperty("订单","order"); 消息持久化消息持久化是保证消息不丢失的重要方式！！！ ActiveMQ提供了三种消息存储方式： 基于Memory消息存储-基于内存的消息存储（不常用） 基于日志消息存储方式，KahaDB是ActiveMQ的默认日志存储方式，它提供了容量的提升和恢复能力 基于JDBC的消息存储方式-数据存储于数据库（例如MySql）中 注意：消费者消费了消息后，持久化的消息要被删除，防止消息被复用 基于Memory消息存储 要使用基于Memory消息存储，需要配置spring.jms.template.delivery-mode=non_persistent 1234567891011# springboot与activemq整合配置spring.activemq.broker-url=tcp://192.168.25.181:61616spring.activemq.user=adminspring.activemq.password=admin# false表示不信任自定义的对象，true表示信任。默认为falsespring.activemq.packages.trust-all=true# 使用基于Memory消息存储spring.jms.template.delivery-mode=non_persistent# 指定发送模式 false是点对点模式 true是发布/订阅模式spring.jms.pub-sub-domain=false 基于日志消息存储方式 要使用基于日志消息存储方式，需要配置spring.jms.template.delivery-mode=persistent 1234567891011# springboot与activemq整合配置spring.activemq.broker-url=tcp://192.168.25.181:61616spring.activemq.user=adminspring.activemq.password=admin# false表示不信任自定义的对象，true表示信任。默认为falsespring.activemq.packages.trust-all=true# 使用基于日志消息存储方式spring.jms.template.delivery-mode=persistent# 指定发送模式 false是点对点模式 true是发布/订阅模式spring.jms.pub-sub-domain=false 存储位置：存储在ActiveMQ部署的服务器端的data目录下的kahaDB下 基于JDBC的消息存储方式 application.properties配置： 1spring.jms.template.delivery-mode=persistent 在ActiveMQ部署的主机上，路径：/usr/local/activemq/conf,修改activemq.xml文件 123456789101112&lt;!-- 配置 数据库连接池 --&gt;&lt;bean name="activemq-mysql" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="clone"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://192.168.31.140:3306/db_activimq" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt;&lt;/bean&gt;&lt;!-- dataSource的值就是数据库的id --&gt;&lt;persistenceAdapter&gt; &lt;jdbcPersistenceAdapter dataSource="#activemq-mysql"/&gt;&lt;/persistenceAdapter&gt; 具体的配置位置如图： 拷贝mysql和druid数据源的jar包到activemq部署主机的activemq的bin目录下 12mysql-connector-java-5.1.28.jardruid-1.0.9.jar 重启activemq,重启前要开启数据库，并创建的有库db_activimq 1$ ./activemq restart 重启成功后，在数据库db-activemq库中就会新增3张表，其中表activemq_msgs记录的就是消息 ActiveMQ的消息事务消息事务是保证消息传递原子性的一个重要特性，和JDBC的事务特征类似 一个事务性发送，基于一组消息，要么能够全部保证到达服务器，要么都不到达服务器 生产者、消费者与消息服务器直接都支持事务性，但是ActiveMQ的事务主要偏向于生产者的应用，即使生产者的消息如果出现异常，所有消息都不能发送到ActiveMQ服务器 生产者应用事务普通版本的事务控制 只需要在创建Session时，打开事务控制即可 1234567891011121314151617181920212223242526272829303132@Testpublic void sendMessageTx()&#123; ConnectionFactory factory = jmsMessagingTemplate.getConnectionFactory(); Session session =null; try &#123; Connection connection = factory.createConnection(); //创建session时，使用true打开事务控制 session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); //创建生产者 MessageProducer producer = session.createProducer(session.createQueue("queue_tx")); //发送消息 for (int i=1;i&lt;=10;i++)&#123; TextMessage textMessage = session.createTextMessage("发送的消息：" + i); producer.send(textMessage); //演示异常 if (i==4)&#123; int j=10/0; &#125; &#125; //注意：一旦开启事务，就必须使用commit进行事务提交，否则无法发送到MQ服务器 session.commit(); &#125; catch (JMSException e) &#123; e.printStackTrace(); //如果出现异常，就回滚 try &#123; session.rollback(); &#125; catch (JMSException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; Spring控制事务 ActiveMQ配置类：com.hui.springbootactivemq.config.ActiveMQConfig 不配置无法控制事务 123456789101112131415161718192021package com.hui.springbootactivemq.config;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.jms.connection.JmsTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import javax.jms.ConnectionFactory;@Configurationpublic class ActiveMQConfig &#123; /** * 添加jms事务管理器 */ @Bean public PlatformTransactionManager createTransactionManager(@Qualifier("jmsConnectionFactory") ConnectionFactory connectionFactory)&#123; return new JmsTransactionManager(connectionFactory); &#125;&#125; 事务版控制事务层：com.hui.springbootactivemq.service.MessageProducerService 123456789101112131415161718192021222324package com.hui.springbootactivemq.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsMessagingTemplate;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service("messageProducerService")public class MessageProducerService &#123; @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @Transactional public void sendMessageTx()&#123; for (int i=1;i&lt;=10;i++)&#123; if (i==4)&#123; int j=10/0; &#125; jmsMessagingTemplate.convertAndSend("spring_queue_tx","发送消息："+i); &#125; &#125;&#125; 测试： 1234567@Autowiredprivate MessageProducerService messageProducerService;@Testpublic void sendMessageSpringTx()&#123; messageProducerService.sendMessageTx();&#125; 消费者应用事务消息监听器应用事务:com.hui.springbootactivemq.listener.MessageListener 123456789101112131415161718192021222324252627282930313233343536package com.hui.springbootactivemq.listener;import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Component;import javax.jms.*;/** * 用于监听消息类，既可用于队列监听，也可以用于主题监听 */@Componentpublic class MessageListener &#123; @JmsListener(destination = "springboot_queue") //如果要控制事务，需要加入session public void receiveMessage(Message message,Session session)&#123; if (message instanceof TextMessage)&#123; TextMessage textMessage=(TextMessage) message; try &#123; System.out.println("接收消息："+textMessage.getText()); //提交事务 session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); //回滚事务 try &#123; //一旦事务回滚，MQ会重发消息，一共重发6次 session.rollback(); &#125; catch (JMSException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>消息持久化</tag>
        <tag>消息事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-Java操作ActiveMQ]]></title>
    <url>%2F2020%2F07%2F15%2F2020-07-14-02-Java%E6%93%8D%E4%BD%9CActiveMQ%2F</url>
    <content type="text"><![CDATA[Java操作ActiveMQ 原生JMS API操作ActiveMQPTP模式引入坐标12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.14.5&lt;/version&gt;&lt;/dependency&gt; 代码实现发送消息 1234567891.创建连接工厂2.创建连接3.打开连接4.创建session5.创建目标地址（Queue：点对点消息，Topic：发布订阅信息）6.创建消息生产者7.创建消息8.发送消息9.释放资源 com.hui.producer.PTP_Producer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.hui.producer;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * 演示点对点模式---消息生产者 */public class PTP_Producer &#123; public static void main(String[] args) throws JMSException &#123; //1.创建连接工厂 ConnectionFactory factory=new ActiveMQConnectionFactory("tcp://192.168.25.181:61616"); //2.创建连接 Connection connection = factory.createConnection(); //3.打开连接 connection.start(); //4.创建session /** * createSession：（后续讲解） * 参数一：是否开启事务 * 参数二：消息确认机制 */ Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建目标地址（Queue：点对点消息，Topic：发布订阅信息）,也是队列地址，指定地址名称是：queue01 Queue queue = session.createQueue("queue01"); //6.创建消息生产者,并指定要发送的队列：queue MessageProducer producer = session.createProducer(queue); //7.创建消息,createTextMessage是文本类型 TextMessage testMessage = session.createTextMessage("test message"); //8.发送消息 producer.send(testMessage); System.out.println("消息发送完成"); //9.释放资源 session.close(); connection.close(); &#125;&#125; 执行该代码，在后台页面可以查看到有一个消息已经发送上了 接收消息-第一种 123456781.创建连接工厂2.创建连接3.打开连接4.创建session5.指定目标地址（Queue：点对点消息，Topic：发布订阅信息）6.创建消息消费者7.接收消息8.释放资源 com.hui.consumer.PTP_Consumer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hui.consumer;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * 演示点对点模式---接收消息，第一种方案 */public class PTP_Consumer &#123; public static void main(String[] args) throws JMSException &#123; //1.创建连接工厂 ConnectionFactory factory=new ActiveMQConnectionFactory("tcp://192.168.25.181:61616"); //2.创建连接 Connection connection = factory.createConnection(); //3.打开连接 connection.start(); //4.创建session /** * createSession： * 参数一：是否开启事务 * 参数二：消息确认机制 */ Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.指定目标地址（Queue：点对点消息，Topic：发布订阅信息）保持和生产者一样 Queue queue = session.createQueue("queue01"); //6.创建消息消费者,并指定从哪个队列接收消息 MessageConsumer consumer = session.createConsumer(queue); //7.接收消息 while (true)&#123; Message message = consumer.receive(); //如果没有消息，就直接结束 if (message==null)&#123; break; &#125; //如果有消息，判断是否是文本类型的消息 if (message instanceof TextMessage)&#123; TextMessage textMessage=(TextMessage) message; System.out.println("接收的消息是："+textMessage.getText()); &#125; &#125; //8.释放资源 session.close(); connection.close(); &#125;&#125; 接收消息-第二种，监听器接收，常用 注意：在监听器的模式下千万不要关闭连接，一旦关闭，消息无法接收 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.hui.consumer;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * 演示点对点模式---接收消息，第二种方案---常用 */public class PTP_ConsumerListener &#123; public static void main(String[] args) throws JMSException &#123; //1.创建连接工厂 ConnectionFactory factory=new ActiveMQConnectionFactory("tcp://192.168.25.181:61616"); //2.创建连接 Connection connection = factory.createConnection(); //3.打开连接 connection.start(); //4.创建session /** * createSession： * 参数一：是否开启事务 * 参数二：消息确认机制 */ Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.指定目标地址（Queue：点对点消息，Topic：发布订阅信息）保持和生产者一样 Queue queue = session.createQueue("queue01"); //6.创建消息消费者,并指定从哪个队列接收消息 MessageConsumer consumer = session.createConsumer(queue); //7.设置监听器来接收消息 consumer.setMessageListener(new MessageListener() &#123; //处理信息 public void onMessage(Message message) &#123; //如果有消息，判断是否是文本类型的消息 if (message instanceof TextMessage)&#123; TextMessage textMessage=(TextMessage) message; try &#123; System.out.println("接收的消息是："+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); //注意：在监听器的模式下千万不要关闭连接，一旦关闭，消息无法接收 &#125;&#125; 发布/订阅模式 注意发布/订阅模式一定要先启动消费者，再启动生产者。就是一定要先订阅，再发送。 订阅消息 因为常用监听模式，这里只使用监听的做演示 com.hui.consumer.PS_ConsumerListener 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.hui.consumer;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * 演示发布/订阅模式---接收消息，第二种方案---常用 */public class PS_ConsumerListener &#123; public static void main(String[] args) throws JMSException &#123; //1.创建连接工厂 ConnectionFactory factory=new ActiveMQConnectionFactory("tcp://192.168.25.181:61616"); //2.创建连接 Connection connection = factory.createConnection(); //3.打开连接 connection.start(); //4.创建session /** * createSession： * 参数一：是否开启事务 * 参数二：消息确认机制 */ Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.指定目标地址（Queue：点对点消息，Topic：发布订阅信息）保持和生产者一样 Topic topic = session.createTopic("topic01"); //6.创建消息消费者,并指定从哪个队列接收消息 MessageConsumer consumer = session.createConsumer(topic); //7.设置监听器来接收消息 consumer.setMessageListener(new MessageListener() &#123; //处理信息 public void onMessage(Message message) &#123; //如果有消息，判断是否是文本类型的消息 if (message instanceof TextMessage)&#123; TextMessage textMessage=(TextMessage) message; try &#123; System.out.println("接收的消息是："+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); //注意：在监听器的模式下千万不要关闭连接，一旦关闭，消息无法接收 &#125;&#125; 发送消息 com.hui.producer.PS_Producer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.hui.producer;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * 演示发布/订阅模式---消息生产者 */public class PS_Producer &#123; public static void main(String[] args) throws JMSException &#123; //1.创建连接工厂 ConnectionFactory factory=new ActiveMQConnectionFactory("tcp://192.168.25.181:61616"); //2.创建连接 Connection connection = factory.createConnection(); //3.打开连接 connection.start(); //4.创建session /** * createSession： * 参数一：是否开启事务 * 参数二：消息确认机制 */ Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建目标地址（Queue：点对点消息，Topic：发布订阅信息）,也是队列地址，指定地址名称是：topic01 Topic topic = session.createTopic("topic01"); //6.创建消息生产者,并指定要发送的队列：queue MessageProducer producer = session.createProducer(topic); //7.创建消息,createTextMessage是文本类型 TextMessage testMessage = session.createTextMessage("test message--topic"); //8.发送消息 producer.send(testMessage); System.out.println("消息发送完成"); //9.释放资源 session.close(); connection.close(); &#125;&#125; Spring操作ActiveMQ添加pom依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--这个jar包是必须的 5.0.2.RELEASE版本的Spring需要使用JMS 2.0版本，但spring-jms的依赖没有自动导入JMS 2.0，而activemq-core会导入JMS 1.1的依赖 所以需要添加以下依赖解决 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.jms&lt;/groupId&gt; &lt;artifactId&gt;javax.jms-api&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.14.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 发送消息Spring整合ActiveMQ的xml文件applicationContext-producer.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:amq="http://activemq.apache.org/schema/core" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd"&gt; &lt;!--创建连接工厂--&gt; &lt;amq:connectionFactory id="amqConnectionFactory" brokerURL="tcp://192.168.25.181:61616" userName="admin" password="admin"/&gt; &lt;!--创建缓存连接工厂--&gt; &lt;bean id="cachingConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"&gt; &lt;!--注入连接工厂--&gt; &lt;property name="targetConnectionFactory" ref="amqConnectionFactory"/&gt; &lt;!--缓存消息信息--&gt; &lt;property name="sessionCacheSize" value="5"/&gt; &lt;/bean&gt; &lt;!--创建用于点对点发送的JmsTemplate--&gt; &lt;bean id="jmsQueueTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!--注入缓存连接工厂--&gt; &lt;property name="connectionFactory" ref="cachingConnectionFactory"/&gt; &lt;!--指定是否为点对点模式 为false就是点对点模式--&gt; &lt;property name="pubSubDomain" value="false"/&gt; &lt;/bean&gt; &lt;!--创建用于发布/订阅发送的JmsTemplate--&gt; &lt;bean id="jmsTopicTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!--注入缓存连接工厂--&gt; &lt;property name="connectionFactory" ref="cachingConnectionFactory"/&gt; &lt;!--指定是否为发布/订阅模式 为true就是发布/订阅模式--&gt; &lt;property name="pubSubDomain" value="true"/&gt; &lt;/bean&gt;&lt;/beans&gt; 发送消息代码实现 点对点模式 com.hui.producer.Spring_PTPProducer 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.hui.producer;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import javax.jms.TextMessage;/** * spring与activemq整合的点对点发送演示 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:applicationContext-producer.xml")public class Spring_PTPProducer &#123; //@Resource(name = "JmsQueueTemplate") @Autowired @Qualifier("jmsQueueTemplate") private JmsTemplate jmsQueueTemplate; @Test public void ptpSender()&#123; /** * 参数一：指定队列的名称 * 参数二：MessageCreator接口，我们需要提供该接口的匿名内部实现 */ jmsQueueTemplate.send("spring-ptp", new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage("spring-queue message"); return textMessage; &#125; &#125;); System.out.println("queue消息发送成功"); &#125;&#125; 发布/订阅模式 com.hui.producer.Spring_PSProducer 12345678910111213141516171819202122232425262728293031323334353637383940package com.hui.producer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import javax.jms.TextMessage;/** * spring与activemq整合的发布/订阅发送演示 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:applicationContext-producer.xml")public class Spring_PSProducer &#123; @Resource(name = "jmsTopicTemplate") private JmsTemplate jmsTopicTemplate; @Test public void pcSender()&#123; /** * 参数一：指定队列的名称 * 参数二：MessageCreator接口，我们需要提供该接口的匿名内部实现 */ jmsTopicTemplate.send("spring-pc", new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage("spring-topic message"); return textMessage; &#125; &#125;); System.out.println("topic消息发送成功"); &#125;&#125; 接收消息Spring整合ActiveMQ的xml文件applicationContext-consumer.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:amq="http://activemq.apache.org/schema/core" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd"&gt; &lt;!--创建连接工厂--&gt; &lt;amq:connectionFactory id="amqConnectionFactory" brokerURL="tcp://192.168.25.181:61616" userName="admin" password="admin"/&gt; &lt;!--创建缓存连接工厂--&gt; &lt;bean id="cachingConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"&gt; &lt;!--注入连接工厂--&gt; &lt;property name="targetConnectionFactory" ref="amqConnectionFactory"/&gt; &lt;!--缓存消息信息--&gt; &lt;property name="sessionCacheSize" value="5"/&gt; &lt;/bean&gt; &lt;!--配置消息监听主键扫描--&gt; &lt;context:component-scan base-package="com.hui.listener"/&gt; &lt;!--配置监听器（点对点）--&gt; &lt;!-- destination-type:目标的类型（queue：点对点模式，topic：发布/订阅模式） --&gt; &lt;jms:listener-container connection-factory="cachingConnectionFactory" destination-type="queue"&gt; &lt;!-- destination:监听的队列名称 ref：监听类，需要代码编写，使用component注解注入到容器中 --&gt; &lt;jms:listener destination="spring-ptp" ref="queueListener"/&gt; &lt;/jms:listener-container&gt; &lt;!--配置监听器（发布/订阅）--&gt; &lt;!-- destination-type:目标的类型（queue：点对点模式，topic：发布/订阅模式） --&gt; &lt;jms:listener-container connection-factory="cachingConnectionFactory" destination-type="topic"&gt; &lt;!-- destination:监听的队列名称 ref：监听类，需要代码编写，使用component注解注入到容器中 --&gt; &lt;jms:listener destination="spring-pc" ref="topicListener"/&gt; &lt;/jms:listener-container&gt;&lt;/beans&gt; 监听器代码实现点对点模式监听 com.hui.listener.QueueListener 123456789101112131415161718192021222324252627package com.hui.listener;import org.springframework.stereotype.Component;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;/** * 点对点模式的监听类 */@Componentpublic class QueueListener implements MessageListener &#123; //接收消息 public void onMessage(Message message) &#123; if (message instanceof TextMessage)&#123; TextMessage testMessage = (TextMessage)message; try &#123; System.out.println("topic的消息："+testMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 发布/订阅模式监听 com.hui.listener.TopicListener 123456789101112131415161718192021222324252627package com.hui.listener;import org.springframework.stereotype.Component;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;/** * 发布/订阅模式的监听类 */@Componentpublic class TopicListener implements MessageListener &#123; //接收消息 public void onMessage(Message message) &#123; if (message instanceof TextMessage)&#123; TextMessage testMessage = (TextMessage)message; try &#123; System.out.println("topic的消息："+testMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 启动监听器com.hui.consumer.SpringConsumer 12345678910111213141516171819202122package com.hui.consumer;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;/** * 用于启动消费方监听 */public class SpringConsumer &#123; public static void main(String[] args) throws IOException &#123; //1.加载配置文件 ClassPathXmlApplicationContext context= new ClassPathXmlApplicationContext("classpath:applicationContext-consumer.xml"); //2.启动 context.start(); //3.阻塞方法，让程序一直处于等待状态，不停止 System.in.read(); &#125;&#125; SpringBoot操作ActiveMQpom文件的依赖123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; appliction.properties配置 注意：如果想要切换点对点模式和发布/订阅模式，只需要修改spring.jms.pub-sub-domain既可，代码不用改 1234567891011server.port=8080# 服务名称（与SpringCloud整合使用）spring.application.name=activemq-producer# springboot与activemq整合配置spring.activemq.broker-url=tcp://192.168.25.181:61616spring.activemq.user=adminspring.activemq.password=admin# 指定发送模式 false是点对点模式 true是发布/订阅模式spring.jms.pub-sub-domain=false 发送消息com.hui.producer.SpringBootProducer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hui.producer;import com.hui.springbootactivemq.SpringbootactivemqApplication;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jms.core.JmsMessagingTemplate;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 演示springboot与activemq的整合--消息生产者 */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = SpringbootactivemqApplication.class)public class SpringBootProducer &#123; @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @Autowired private JmsTemplate jmsTemplate; @Test public void ptpSender()&#123; /** * 第一种发送消息的方法 * 参数一：队列的名称 * 参数二：消息内容 */ jmsMessagingTemplate.convertAndSend("springboot-queue","springboot queue message"); System.out.println("消息发送成功"); &#125; @Test public void ptpSender2()&#123; /** * 第二种发送消息的方法 */ jmsTemplate.send("springboot_queue2", new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage("springboot queue message2"); return textMessage; &#125; &#125;); System.out.println("消息发送成功"); &#125;&#125; 接收消息 注意：接收消息的监听包必须和启动类在一个包下：springbootactivemq com.hui.springbootactivemq.listener.MessageListener 123456789101112131415161718192021222324252627package com.hui.springbootactivemq.listener;import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Component;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.TextMessage;/** * 用于监听消息类，既可用于队列监听，也可以用于主题监听 */@Componentpublic class MessageListener &#123; @JmsListener(destination = "springboot_queue") public void receiveMessage(Message message)&#123; if (message instanceof TextMessage)&#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println("接收到的消息："+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ActiveMQ</category>
        <category>JMS API</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[01-ActiveMQ简介及JMS]]></title>
    <url>%2F2020%2F07%2F15%2F2020-07-14-01-ActiveMQ%E7%AE%80%E4%BB%8B%E5%8F%8AJMS%2F</url>
    <content type="text"><![CDATA[ActiveMQ简介及JMS ActiveMQ简介及JMS什么是ActiveMQactiveMQ官网 ActiveMQ的应用场景ActiveMQ可以用于做：异步处理、应用解耦、流量削锋 什么是JMSJMS是java平台上有关面向消息中间件的技术规范，它便于消息系统中的java应用程序进行信息交换，并且通过提供标准的产生、发送、接受消息的接口简化企业应用的开发。 JMS消息模型消息中间件一般有两种传递模式：点对点模式（P2P）和发布-订阅模式（Pub、Sub） P2P点对点模式：Queue队列模式 Publish/Subscribe发布/订阅模式：Topic主题模式 点对点模式 生产者和消费者之间的消息往来 clientA是发布者，clientB是消费者，一个消息只有一个消费者 每个消息都被发送到特定的消息队列，接受者从队列中获取消息。队列保留着消息，知道他们被消费或超时 特点： 每个消息只有一个消费者（consumer），即一旦被消费，消息就不再在队列中了 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列。 接收者在成功接收消息之后需向队列应答成功 发布/订阅模式 包含三个角色：主题（Topic），发布者（Publisher)，订阅者（Subscriber），多个发布者将消息发送到topic，系统将这些消息投递到订阅此topic的订阅者 clientA是发送者，clientB和ClientC是订阅者，一个消息可以有多个订阅者 发送者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息。，所以从1到N个订阅者都能得到这个消息的拷贝。 特点： 每个消息可以有多个消费者 发布者和订阅者之间有时间上的依赖性，要先订阅主题，再来发送消息（不能先发送，再订阅） 订阅者必须保持运行的转态，才能接受发布者发布的消息 JMS编程API 要素 作用 Destination 表示消息所有通道的目标定义，用来定义消息从发送端发出后要走的通道，而不是接收方。Destination属于管理类对象 ConnectionFactory 顾名思义，用于创建连接对象。ConnectionFactory属于管理类对象 Connection 连接接口，所负责的重要工作是创建Session Session 会话接口，这是一个非常重要的对象，消息发送者、消息接收者以及消息对象本身，都是通过这个会话对象创建的 MessageConsumer 消息的消费者，也就是订阅消息并处理消息的对象 MessageProducer 消息的生产者，也就是用来发送消息的对象 Destination：Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源，对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）；对于消费者来说，它的Destination也是某个队列或主题（即消息来源）。所以，Destination实际上就是两种类型的对象：Queue、Topic ConnectionFactory：创建Connection对象的工厂，针对两种不同jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种 Connection：表示在客户端和JMS系统之间建立的连接（对TCP/IP socket的包装），Connection可以产生一个或多个Session Session：Session是我们对消息进行操作的接口，可以通过session创建生产者、消费者、消息等。Session提供了事务的功能，如果需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中 Producer（消息生产者）：消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send和publish方法）发送消息 Consumer（消息消费者）：消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver（Queue）或createSubscriber（Topic）来创建。当然，也可以通过session的createDurableSubscriber方法来创建持久化的订阅者 MessageListener：消息监听器。如果注册了消息监听器，一旦消息送到，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener 整个API的图解 ActiveMQ的安装安装activeMQ的下载地址 123456789101112131415# 第一步，安装jdk# 第二步，把activeMQ的压缩包（apache-Activemq-5.14.5-bin.tar.gz）上传到linux系统# 第三步 解压压缩包$ tar -zxvf apache-Activemq-5.14.5-bin.tar.gz# 第四步 进入apache-Activemq-5.14.5的bin目录$ cd apache-Activemq-5.14.5/bin# 第五步 启动activemq./activemq start# 第六步 停止activemq./activemq stop 访问12页面控制台：http://192.168.25.180:8161/ (监控)请求地址：tcp:ip:61616 （java代码访问消息中间件） 账号密码都是：admin]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>JMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-redis使用]]></title>
    <url>%2F2020%2F04%2F02%2F2020-04-01-02-redis%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[02-redis使用 Redis的使用spring中使用redis依赖Jar包123456789101112&lt;--我用的版本：3.2.0--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;$&#123;redis.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;--我用的版本：2.2.5.RELEASE--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.redis.version&#125;&lt;/version&gt;&lt;/dependency&gt; Spring-redis配置在spring的xml中，配置redis的连接池，并按照spring的规范，定义redisTemplate，方便service的调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd "&gt; &lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true" /&gt; &lt;!-- redis集群开始 --&gt; &lt;!-- string redis template definition 这个和下面的redisTemplate只能留一个--&gt;&lt;!-- &lt;bean id="stringRedisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate"&gt;--&gt;&lt;!-- &lt;property name="connectionFactory" ref="jedisConnectionFactory" /&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt; &lt;!-- redis template definition --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt; &lt;property name="connectionFactory" ref="jedisConnectionFactory" /&gt; &lt;property name="keySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="hashKeySerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="hashValueSerializer"&gt; &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Spring-redis连接池管理工厂 --&gt; &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;constructor-arg ref="redisClusterConfiguration" /&gt; &lt;constructor-arg ref="jedisPoolConfig" /&gt; &lt;/bean&gt; &lt;!-- 集群配置 --&gt; &lt;bean id="redisClusterConfiguration" class="org.springframework.data.redis.connection.RedisClusterConfiguration"&gt; &lt;property name="clusterNodes"&gt; &lt;set&gt; &lt;ref bean="clusterRedisNodes1"/&gt; &lt;ref bean="clusterRedisNodes2"/&gt; &lt;ref bean="clusterRedisNodes3"/&gt; &lt;ref bean="clusterRedisNodes4"/&gt; &lt;ref bean="clusterRedisNodes5"/&gt; &lt;ref bean="clusterRedisNodes6"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="maxRedirects" value="$&#123;spring.redis.maxRedirects&#125;" /&gt; &lt;/bean&gt; &lt;!-- 集群节点 --&gt; &lt;bean id="clusterRedisNodes1" class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes1.host&#125;" /&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes1.port&#125;" type="int" /&gt; &lt;/bean&gt; &lt;bean id="clusterRedisNodes2" class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes2.host&#125;" /&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes2.port&#125;" type="int" /&gt; &lt;/bean&gt; &lt;bean id="clusterRedisNodes3" class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes3.host&#125;" /&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes3.port&#125;" type="int" /&gt; &lt;/bean&gt; &lt;bean id="clusterRedisNodes4" class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes4.host&#125;" /&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes4.port&#125;" type="int" /&gt; &lt;/bean&gt; &lt;bean id="clusterRedisNodes5" class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes5.host&#125;" /&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes5.port&#125;" type="int" /&gt; &lt;/bean&gt; &lt;bean id="clusterRedisNodes6" class="org.springframework.data.redis.connection.RedisNode"&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes6.host&#125;" /&gt; &lt;constructor-arg value="$&#123;spring.redis.cluster.nodes6.port&#125;" type="int" /&gt; &lt;/bean&gt; &lt;!-- jedis配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="$&#123;spring.redis.pool.max-active&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;spring.redis.pool.max-idle&#125;" /&gt; &lt;property name="minIdle" value="$&#123;spring.redis.pool.min-idle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;spring.redis.pool.max-wait&#125;" /&gt; &lt;property name="testOnBorrow" value="true" /&gt; &lt;/bean&gt;&lt;/beans&gt; redis.properties配置文件123456789101112131415161718192021222324252627###redis集群推送任务信息缓存spring.redis.cluster.nodes1.host=192.168.25.152spring.redis.cluster.nodes1.port=7000spring.redis.cluster.nodes2.host=192.168.25.152spring.redis.cluster.nodes2.port=7001spring.redis.cluster.nodes3.host=192.168.25.153spring.redis.cluster.nodes3.port=7000spring.redis.cluster.nodes4.host=192.168.25.153spring.redis.cluster.nodes4.port=7001spring.redis.cluster.nodes5.host=192.168.25.154spring.redis.cluster.nodes5.port=7000spring.redis.cluster.nodes6.host=192.168.25.154spring.redis.cluster.nodes6.port=7001## Redis数据库索引(默认为0) spring.redis.database=0## 连接超时时间（毫秒） spring.redis.timeout=60000## 最大重试次数spring.redis.maxRedirects=3## 连接池最大连接数（使用负值表示没有限制）如果是集群就是每个ip的连接数 spring.redis.pool.max-active=300## 连接池最大阻塞等待时间（使用负值表示没有限制） spring.redis.pool.max-wait=-1## 连接池中的最大空闲连接 spring.redis.pool.max-idle=100## 连接池中的最小空闲连接 spring.redis.pool.min-idle=20 使用方法工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647package com.hui.utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.data.redis.core.Cursor;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ScanOptions;import org.springframework.data.redis.core.ZSetOperations;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;public class RedisUtil&#123; private Logger log = LoggerFactory.getLogger(this.getClass()); private final RedisTemplate&lt;String, Object&gt; redisTemplate; public RedisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; //初始化时加载容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:SpringRedis.xml"); redisTemplate = applicationContext.getBean(RedisTemplate.class); this.redisTemplate = redisTemplate; &#125; /** * 指定缓存失效时间 * * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 根据key 获取过期时间 * * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key) &#123; return redisTemplate.getExpire(key, TimeUnit.SECONDS); &#125; /** * 判断key是否存在 * * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key) &#123; try &#123; return redisTemplate.hasKey(key); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 删除缓存 * * @param key 可以传一个值 或多个 */ @SuppressWarnings("unchecked") public void del(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete(CollectionUtils.arrayToList(key)); &#125; &#125; &#125; // ============================String============================= /** * 普通缓存获取 * * @param key 键 * @return 值 */ public Object get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 递增 * * @param key 键 * @param delta 要增加几(大于0) * @return */ public long incr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException("递增因子必须大于0"); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; /** * 递减 * * @param key 键 * @param delta 要减少几(小于0) * @return */ public long decr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException("递减因子必须大于0"); &#125; return redisTemplate.opsForValue().increment(key, -delta); &#125; // ================================Map================================= /** * HashGet * * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key, String item) &#123; return redisTemplate.opsForHash().get(key, item); &#125; /** * 获取hashKey对应的所有键值 * * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object, Object&gt; hmget(String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * HashSet * * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * HashSet 并设置时间 * * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value, long time) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 删除hash表中的值 * * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item) &#123; redisTemplate.opsForHash().delete(key, item); &#125; /** * 判断hash表中是否有该项的值 * * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item) &#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; /** * hash递减 * * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, -by); &#125; // ============================set============================= /** * 根据key获取Set中的所有值 * * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key) &#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return null; &#125; &#125; /** * 根据value从一个set中查询,是否存在 * * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key, Object value) &#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 将数据放入set缓存 * * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values) &#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return 0; &#125; &#125; /** * 将set数据放入缓存 * * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().add(key, values); if (time &gt; 0) expire(key, time); return count; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return 0; &#125; &#125; /** * 获取set缓存的长度 * * @param key 键 * @return */ public long sGetSetSize(String key) &#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return 0; &#125; &#125; /** * 移除值为value的 * * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return 0; &#125; &#125; // ===============================list================================= /** * 获取list缓存的内容 * * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end) &#123; try &#123; return redisTemplate.opsForList().range(key, start, end); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return null; &#125; &#125; /** * 获取list缓存的长度 * * @param key 键 * @return */ public long lGetListSize(String key) &#123; try &#123; return redisTemplate.opsForList().size(key); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return 0; &#125; &#125; /** * 通过索引 获取list中的值 * * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key, long index) &#123; try &#123; return redisTemplate.opsForList().index(key, index); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return null; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 根据索引修改list中的某条数据 * * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value) &#123; try &#123; redisTemplate.opsForList().set(key, index, value); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * 移除N个值为value * * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key, long count, Object value) &#123; try &#123; Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return 0; &#125; &#125; // ===============================sorted set================================= /** * 向有序集合添加一个成员的 * &lt;p&gt; * ZADD key score1 member1 [score2 member2] */ public boolean zadd(String key, Object member, double score, long time) &#123; try &#123; redisTemplate.opsForZSet().add(key, member, score); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return false; &#125; &#125; /** * ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] * 通过分数返回有序集合指定区间内的成员 */ public Set&lt;Object&gt; zRangeByScore(String key, double minScore, double maxScore) &#123; try &#123; return redisTemplate.opsForZSet().rangeByScore(key, minScore, maxScore); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return null; &#125; &#125; /** * ZSCORE key member * 返回有序集中，成员的分数值 */ public Double zscore(String key, Object member) &#123; try &#123; return redisTemplate.opsForZSet().score(key, member); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return null; &#125; &#125; /** * ZRANK key member 返回有序集合中指定成员的索引 */ public Long zrank(String key, Object member) &#123; try &#123; return redisTemplate.opsForZSet().rank(key, member); &#125; catch (Exception e) &#123; log.error("redis error: ", e); return null; &#125; &#125; /** * Zscan 迭代有序集合中的元素（包括元素成员和元素分值） */ public Cursor&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; zscan(String key) &#123; try &#123; Cursor&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; cursor = redisTemplate.opsForZSet().scan(key, ScanOptions.NONE); return cursor; &#125; catch (Exception e) &#123; log.error("redis error: ", e); return null; &#125; &#125;&#125; 测试类 12345678910111213141516171819202122232425262728package com.hui.test;import com.hui.utils.RedisUtil;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import java.io.IOException;public class DemoTest &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @Autowired private RedisTemplate template; @Test public void testhelper() throws IOException &#123; RedisUtil redisUtil=new RedisUtil(template); //设值 redisUtil.set("address", "beijing"); //通过key获取值 String value= (String) redisUtil.get("address"); System.out.println(value); &#125;&#125; springboot中使用redis暂时未记录，后续补上]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-redis搭建]]></title>
    <url>%2F2020%2F04%2F02%2F2020-04-01-01-redis%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[01-redis搭建 Redis介绍和使用什么是redisRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库（nosql），应用在缓存。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型有5种。 Redis中所有数据都是字符串 redis的安装这里主要介绍源码的安装方式，安装包的安装方式自行百度解决。 环境准备 123456789101112#1.安装gcc g++的依赖库$ sudo apt-get install build-essential$ sudo apt-get install libtool#2.安装pcre依赖库$ sudo apt-get update$ sudo apt-get install libpcre3 libpcre3-dev#3.安装zlib依赖库$ sudo apt-get install zlib1g-dev#4.安装ssl依赖库$ sudo apt-get install openssl#5.验证gcc是否安装成功$ gcc -v 安装Redis,Redis官网 123456# 下载1.8.0版本：sudo wget wget http://download.redis.io/releases/redis-4.0.8.tar.gz# 解压：tar -zxvf redis-4.0.8.tar.gz#进入解压目录：cd redis-4.0.8 编译和安装 1234#1.生成脚本和配置文件$ make#2.安装 ，如果一下命令没有安装到/usr/local下，需要先mkdir /usr/local/redis$ sudo make install PREFIX=/usr/local/redis 如果编译出错，可以make clean后重新make，进行编译 启动redis 先添加一下redis的日志文件，后面发现没有日志使用./redis-cli shutdown时会报错,在/usr/local/redis/bin/redis.conf文件下编译logfile &quot;&quot;为logfile &quot;redis.log&quot;,这里的路径是相对路径，如果启动不了，使用chmod 777 redis.log赋权 1234#进入启动目录cd /usr/local/redis/bin#启动redis./redis-server 启动结果如下，这样启动是前台的启动，控制台被占用，无法再操作控制台，所以设置守护进程启动。下面那个我按ctrl+c无法关闭，后来还是杀进程关闭的 设置守护进程启动 12#复制一份redis.conf文件到/usr/local/redis/bin$ sudo cp /home/wanghui/redis-4.0.8/redis.conf /usr/local/redis/bin 修改daemonize no 改成daemonize yes 后端启动 1234567891011$ cd /usr/local/redis/bin#通过制定redis.conf来启动redis$ sudo ./redis-server redis.conf#查看进程是否启动$ ps -ef | grep redis# 连接redis,完整命令为 ./redis-cli -h 192.168.25.152(ip) -p 6379(端口)$ ./redis-cli#断开连接ctrl+c#关闭redis服务，杀死redis进程也可以$ ./redis-cli shutdown redis的使用5中键值对数据里库类型使用如下： 字符串类型（String）：存的是key-value set key value 设置值 (例如：set name zhangsan) get key 获取值 incr key 加一，如果value设置的不是数字，是不能执行的 decr key减一 数列类型（hash）：相当于一个key对应一个map(map中又是key-value) hset key field value 设置值 hget key field 获取值 hincrby key field num 设置增数量 列表类型（List）：list是有顺序，可重复，可从左边添加元素，也可以从右边添加元素 lpush list a b c d ：从右面向左边添加元素（从左边添加元素），即d c b a，其中list是名称 rpuah list 1 2 3 4：从右边添加元素 lrange list 0 -1 ：从0到-1元素查看，表示查看所有 lpop：从左边取，取出的同时也是被删除了 rpop：从右边取，取出的同时也是被删除了 集合类型（set）：无顺序，不能重复，如果添加重复元素，只会加入一个 sadd set1 a b c d d :像set1中添加元素 smembers set1:查询名称为set1下的元素 srem set1 a：删除名称为set1下的a元素 有序集合类型（SortedSet）：也叫zset，有顺序，不能重复。适合做排行榜 zadd zset1 9 a 8 c 10 d 1 e:添加元素（zadd zset1 score member）,这个添加了4个元素，分别是a c d e，其对应分数分别为9 8 10 1 zrange zset1 0 -1：根据zset1中的分数（从低到高）查看元素（这里的a c d e是元素） zrange zset1 0 -1 withscores ：查看所有元素和分数 zrevrange zset1 0 -1 :按分数降序（分数从高到低）排序查看元素 zincrby zset1 5 a：对a元素添加5分，得到的结果是a元素变成14分（9+5） 常用命令auth password：输入密码 dbsize：查看key的数量 expire key second：设置key的过期时间（单位是秒） ttl key：查看key距离过期的剩余时间（-2表示不存在，-1表示已被持久化，正数表示剩余的时间） persist key：清除过期时间，也就是持久化，持久化成功提示是1，失败提示是0 del key：删除key EXISTS key：查看key是否存在，若key存在，返回1，否则返回0 select 0：表示，选择0号数据库，默认是0号数据库 redis的持久化方案Redis的数据都保存在内存中，如果机器挂掉，内存中的数据就不存在，因此需要做持久化，将内存中的数据保存在磁盘，下一次启动的时候就可以恢复数据到内存中 redis有两种持久化的方式 RDB ：快照形式，定期将当前数据保存到磁盘中，会产生一个dump.rdb(redis的bin目录下)文件。 特点：会存在数据丢失，性能较好，数据备份。 使用方式： 在redis.conf中默认配置了保存规则及时间间隔 123save 900 1 //表示在900秒（15分钟）内修改了至少1个key，就会产生一个dump.rdb文件save 300 10 //表示在300秒（5分钟）内修改了至少10个key，就会产生一个dump.rdb文件save 60 10000 //表示在60秒（1分钟）内修改了至少10000个key，就会产生一个dump.rdb文件 AOF：append only file，所有对redis的操作命令记录在aof文件中，恢复数据，重新执行一遍即可。 特点：每秒保存（可以设置每次操作都保存一次），数据比较完整，耗费性能 默认是不开启的，如果需要开启，需要在redis.conf下修改配置 1appendonly no //将no改成yes就开启了AOF 重新运行redis，会在bin目录下生成一个appendonly.aof的文件 redis默认开启的是RDB，如果同时开启两个持久化方案，会按照AOF的持久化方案恢复数据 redis集群的搭建redis cluster节点分配现在我们是三个主节点分别是：A, B, C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是： 节点A覆盖0－5460 节点B覆盖5461－10922 节点C覆盖10923－16383 获取数据:如果存入一个值，按照redis cluster哈希槽的算法： CRC16(‘key’)384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据 新增一个主节点:新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样： 节点A覆盖1365-5460 节点B覆盖6827-10922 节点C覆盖12288-16383 节点D覆盖0-1364,5461-6826,10923-12287 同样删除一个节点也是类似，移动完成后就可以删除这个节点了。 Redis Cluster主从模式 redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉 上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了。A和C的slot也无法访问。 所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。 B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。 不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。 redis-cluster集群的搭建环境 12345操作系统：Ubuntu18.04redis版本：5.0.3redis集群环境：192.168.25.152 192.168.25.153 192.168.25.154每个环境上有2个节点，一个maste，一个slave 集群中至少应该有奇数个节点，所以至少有三个节点，每个节点至少有一个备份节点，所以下面使用6节点（主节点、备份节点由redis-cluster集群确定） 安装redis，这里我把3个主节点放在3台服务器上，分别安装，安装步骤操作单节点的安装。从节点我分别装在对应的主节点服务器上 1、安装redis并配置 安装方式见redis单节点的安装，然后在/usr/local下创建文件夹redis-cluster,复制两份redis到redis-cluster文件夹下，命名为redis-master和redis-slave。 修改redis .conf配置文件的部分内容如下： 12345678910bind 192.168.25.152 # 可以不用改port 7000 #修改端口号daemonize yes #后台启动,单节点时就配置好了pidfile /var/run/redis_7001.piddir /usr/local/redis-cluster/redis-master/bin/redis-data # 比较重要，因为备份文件存在这个配置的redis-data文件夹下cluster-enabled yes #开启cluster，去掉注释cluster-config-file nodes-7000.conf #自动生成 ，去掉注释cluster-node-timeout 15000 #节点通信时间， 去掉注释appendonly no #持久化方式，使用默认的持久化方式就可cluster-require-full-coverage no # redis cluster需要16384个slot都正常的时候才能对外提供服务，换句话说，只要任何一个slot异常那么整个cluster不对外提供服务。 因此生产环境一般为no 去掉注释，改成no 2、运行redis实例 在3个服务器上分别执行一下命令启动redis,可以在redis-cluster文件夹下直接写成脚本 123456#!/bin/bashcd /usr/local/redis-cluster/redis-master/bin./redis-server redis.confcd /usr/local/redis-cluster/redis-slave/bin./redis-server redis.confecho "redis-cluste start success" 编写shutdown的脚本 12345678910111213141516171819202122232425262728293031323334353637#!/bin/bash#1. 定义关键字查询进程信息findstr=`echo "redis"`#2. 查询进程信息保存于proids ps -ef|grep '$&#123;findstr&#125;' |grep -v 'grep'|awk '&#123;print $2&#125;'i=0for proid in `ps -ef|grep "$&#123;findstr&#125;"|grep -v 'grep' |awk '&#123;print $2&#125;'`do proids[$i]=$proid let i=$i+1done#3. 判断查出的进程的数量 if [ $&#123;#proids[*]&#125; -eq 0 ]; then echo "not find proid"elif [ $&#123;#proids[*]&#125; -eq 1 ]; then kill -9 $&#123;proids[0]&#125; echo "proid[$&#123;proids[0]&#125;] was killed"else for proid in $&#123;proids[@]&#125; do #4 .把多个进程放到一起，先判断是否为空，如果为空，执行else，接下来不在为空，执行if。这步先留着，其实可以不要 if [ $proidstr ]; then proidstr="$proidstr,$proid" else proidstr="$proid" fi #5. 杀死进程 kill -9 $proid done echo "存在$&#123;#proids[*]&#125;条进程[$&#123;proidstr&#125;], was killed"fi 修改脚本操作权限并启动 123456$ sudo chmod 777 start-all.sh$ sudo chmod 777 shutdown-all.sh# 开启$ sudo ./start-all.sh# 关闭$ sudo ./shutdown-all.sh 查看是否启动 1ps -ef | grep redis 3、创建开启redis-cluster 创建开启redis-cluster前需要把所有的redis都启动，然后使用152,153,154中的随便一台服务器。例如我使用的是152服务器上的7000端口的redis 1234567891011121314# 1.进入源文件的src路径(不是安装的位置，是源文件的位置)$ cd /home/wanghui/redis-5.0.3/src# 2.创建集群$ sudo ./redis-cli --cluster create 192.168.25.152:7000 192.168.25.152:7001 192.168.25.153:7000 192.168.25.153:7001 192.168.25.154:7000 192.168.25.154:7001 --cluster-replicas 1# 集群方式登录./redis-cli -c -h 192.168.25.152 -p 7000# 登录进去后，查看集群状态cluster info# 查看集群节点cluster nodes# 检查集群节点状态./redis-cli --cluster check 192.168.25.152:7000# 修复集群节点./redis-cli --cluster fix 192.168.25.152:7000]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-Mybatis逆向工程使用]]></title>
    <url>%2F2020%2F04%2F02%2F2020-04-01-02-Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[02-Mybatis逆向工程使用 Mybatis逆向工程使用不使用spring+不使用mapper代理SqlMapConfig.xml的配置 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 引入数据源配置 database.properties 文件 --&gt; &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt; &lt;!--配置mybatis 运行中的一些行为 --&gt; &lt;settings&gt; &lt;!-- 设置Mybatis的log实现为LOG4J --&gt; &lt;setting name="logImpl" value="LOG4J"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- &lt;typeAlias alias="User" type="com.zy.entity.User"/&gt; --&gt; &lt;package name="com.hui.pojo"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置mybatis运行环境 --&gt; &lt;environments default="dev"&gt; &lt;environment id="dev"&gt; &lt;!-- 采用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 采用Mybatis自带的数据源 POOLED --&gt; &lt;dataSource type="POOLED" &gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将mapper文件加入到配置文件中 我的mapper文件放在了resources的mapper文件夹下--&gt; &lt;mappers&gt; &lt;mapper resource="mapper/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; jdbc.properties的配置 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://192.168.31.140:3306/test?characterEncoding=utf-8jdbc.username=rootjdbc.password=123456 测试的类 1234567891011121314151617181920212223242526272829package com.hui.test;import com.hui.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import java.io.IOException;import java.io.InputStream;public class DemoTest &#123; @Test public void testSession() throws IOException &#123; //加载mybatis的配置文件 String resources="SqlMapConfig.xml"; InputStream inputStream= Resources.getResourceAsStream(resources); //获取sqlSessionFactory工厂 SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); //通过工程获取sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //执行sql语句 user是命名空间，起了别名的 User user = sqlSession.selectOne("user.selectByPrimaryKey", '1'); System.out.println(user.toString()); //释放资源 sqlSession.close(); &#125;&#125; 不使用spring+使用mapper代理SqlMapConfig.xml和jdbc.properties的配置和不适用spring+不适用mapper代理方式一样，只有测试的类不一样 123456789101112131415161718192021222324252627282930package com.hui.test;import com.hui.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import java.io.IOException;import java.io.InputStream;public class DemoTest &#123; @Test public void testSession() throws IOException &#123; //加载mybatis的配置文件 String resources="SqlMapConfig.xml"; InputStream inputStream= Resources.getResourceAsStream(resources); //获取sqlSessionFactory工厂 SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); //通过工程获取sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 获取mapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.selectByPrimaryKey(1); System.out.println(user.toString()); //释放资源 sqlSession.close(); &#125;&#125; 使用spring+使用mapper代理SqlMapConfig.xml的配置 123456&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;/configuration&gt; applicationContext.xml的配置：管理mybatis 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置 读取properties文件 jdbc.properties --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt; &lt;!-- 配置 数据源 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 设置MyBatis核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml" /&gt; &lt;!-- 设置数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!--配置别名包扫描--&gt; &lt;property name="typeAliasesPackage" value="com.hui.pojo"/&gt; &lt;!--配置mapper的位置 很重要--&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 设置Mapper扫描包 --&gt; &lt;property name="basePackage" value="com.hui.mapper" /&gt; &lt;/bean&gt;&lt;/beans&gt; jdbc.properties的配置和上面的一样 测试的类 12345678910111213141516171819202122232425262728293031323334353637package com.hui.test;import com.hui.mapper.UserMapper;import com.hui.pojo.User;import com.hui.pojo.UserExample;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;import java.util.List;public class DemoTest &#123; @Test public void testhelper() throws IOException &#123; //初始化spring容器 ApplicationContext context=new ClassPathXmlApplicationContext("classpath:spring/applicationContext.xml"); //获取mapper代理对象 UserMapper userMapper = context.getBean(UserMapper.class); UserExample example = new UserExample(); UserExample.Criteria criteria = example.createCriteria(); criteria.andUseridEqualTo(1); List&lt;User&gt; users = userMapper.selectByExample(example); //不设置任何查询条件是查询所有 //UserExample example = new UserExample(); //List&lt;User&gt; users = userMapper.selectByExample(example); //User user = userMapper.selectByPrimaryKey(1); for (User user:users)&#123; System.out.println(user.toString()); &#125; &#125;&#125; mapper接口中的方法解析Mybatis逆向工程中mapper接口中的方法解析 mapper接口中的部分常用方法及功能如下： 方法 功能说明 int countByExample(UserExample example) thorws SQLException 按条件计数 int deleteByPrimaryKey(Integer id) thorws SQLException 按主键删除 int deleteByExample(UserExample example) thorws SQLException 按条件删除 String/Integer insert(User record) thorws SQLException 插入数据（返回值为ID） User selectByPrimaryKey(Integer id) thorws SQLException 按主键查询 ListselectByExample(UserExample example) thorws SQLException 按条件查询 ListselectByExampleWithBLOGs(UserExample example) thorws SQLException 按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生 int updateByPrimaryKey(User record) thorws SQLException 按主键更新 int updateByPrimaryKeySelective(User record) thorws SQLException 按主键更新值不为null的字段 int updateByExample(User record, UserExample example) thorws SQLException 按条件更新 int updateByExampleSelective(User record, UserExample example) thorws SQLException 按条件更新值不为null的字段 Mybatis逆向工程Example类解析mybatis的逆向工程中会生成实体类及实体类对应的example类，example类用于添加条件，相当where后面的部分。 如果要查询所有，就不设置任何查询条件 12UserExample example = new UserExample();List&lt;User&gt; users = userMapper.selectByExample(example); xxxExample example = new xxxExample();Criteria criteria = new Example().createCriteria();example类中的部分常用方法及功能如下： 方法 功能说明 example.setOrderByClause(“字段名 ASC”); 添加升序排列条件，DESC为降序 example.setDistinct(false) 去除重复，boolean型，true为选择不重复的记录 criteria.andXxxIsNull 添加字段xxx为null的条件 criteria.andXxxIsNotNull 添加字段xxx不为null的条件 criteria.andXxxEqualTo(value) 添加xxx字段等于value条件 criteria.andXxxNotEqualTo(value) 添加xxx字段不等于value条件 criteria.andXxxGreaterThan(value) 添加xxx字段大于value条件 criteria.andXxxGreaterThanOrEqualTo(value) 添加xxx字段大于等于value条件 criteria.andXxxLessThan(value) 添加xxx字段小于value条件 criteria.andXxxLessThanOrEqualTo(value) 添加xxx字段小于等于value条件 criteria.andXxxIn(List&lt;？&gt;) 添加xxx字段值在List&lt;？&gt;条件 criteria.andXxxNotIn(List&lt;？&gt;) 添加xxx字段值不在List&lt;？&gt;条件 criteria.andXxxLike(“%”+value+”%”) 添加xxx字段值为value的模糊查询条件 criteria.andXxxNotLike(“%”+value+”%”) 添加xxx字段值不为value的模糊查询条件 criteria.andXxxBetween(value1,value2) 添加xxx字段值在value1和value2之间条件 criteria.andXxxNotBetween(value1,value2) 添加xxx字段值不在value1和value2之间条件]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-Mybatis逆向工程搭建]]></title>
    <url>%2F2020%2F04%2F02%2F2020-04-01-01-Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[01-Mybatis逆向工程搭建 Mybatis逆向工程搭建由于目前很多公司都在使用逆向工程生成Mybatis所需要的mapper文件和pojo文件，所以我这里也总结了一下Mybatis的逆向工程的搭建，亲身实践，绝对可靠 不使用springboot搭建maven工程，导入依赖jar包第一步肯定是要在maven工程中导入所依赖的jar包,主要jar包是下面3个，如果需要，可以在导入log4j的jar包，顺便说一下，我用的mysql数据库版本是5.7.22 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt;&lt;/dependency&gt; 创建generatorConfig.xml配置文件generatorConfig.xml配置文件是逆向工程的核心配置文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- id:必选，上下文id，用于在生成错误时提示 MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample --&gt; &lt;context id="testTables" targetRuntime="MyBatis3"&gt; &lt;!-- 配置生成pojo的序列化的插件，mybatis支持很多插件，这些插件都在 org.mybatis.generator.plugins包下 --&gt; &lt;plugin type="org.mybatis.generator.plugins.SerializablePlugin" /&gt; &lt;!-- 配置生成pojo的toString()方法的插件，mybatis支持很多插件，这些插件都在 org.mybatis.generator.plugins包下 --&gt; &lt;plugin type="org.mybatis.generator.plugins.ToStringPlugin" /&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://192.168.31.140:3306/test?characterEncoding=utf-8" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short； --&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetPackage:生成PO类的位置 --&gt; &lt;!--targetProject:指定存在的目录--&gt; &lt;javaModelGenerator targetPackage="com.hui.pojo" targetProject="src/main/java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.hui.mapper" targetProject="src/main/java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema="" tableName="user"&gt;&lt;/table&gt; &lt;table schema="" tableName="goods"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 编写执行代码GeneratorSqlmap.java新创建一个java执行文件（我创建在了com/hui/startup包下），使用以下代码执行。别忘记了修改逆向工程的配置文件路径 123456789101112131415161718192021222324252627282930313233343536package com.hui.startup;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class GeneratorSqlmap &#123; public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定 逆向工程配置文件 File configFile = new File("src\\main\\resources\\generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行GeneratorSqlmap.java执行后生成的代码结构如下： springboot搭建逆向工程创建springboot初始化时添加的依赖： Spring Boot DevTools Lombok Mybatis Framework Pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.13.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.hui&lt;/groupId&gt; &lt;artifactId&gt;springbootgenerator&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootgenerator&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;targetJavaProject&gt;src/main/java&lt;/targetJavaProject&gt; &lt;!-- XML生成路径 --&gt; &lt;targetResourcesProject&gt;src/main/resources&lt;/targetResourcesProject&gt; &lt;targetXMLPackage&gt;mapper&lt;/targetXMLPackage&gt; &lt;targetMapperPackage&gt;com.hui.dao&lt;/targetMapperPackage&gt; &lt;targetModelPackage&gt;com.hui.pojo&lt;/targetModelPackage&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;!-- generator 工具配置文件的位置 --&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; GeneratorConfig.xmlgeneratorConfig.xml是逆向工程的核心配置文件 该文件放在位置：在resources下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;!-- mybatis-generator的核心配置文件 --&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动位置 --&gt;&lt;!-- &lt;classPathEntry location="D:\maven_repository\mysql\mysql-connector-java\5.1.41\mysql-connector-java-5.1.41.jar" /&gt;--&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://192.168.31.140:3306/test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;!--指定生成的类型为java类型，避免数据库中number等类型字段 --&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!--自动生成的实体的存放包路径 举个例子：生成Goods.java和GoodsExample.java--&gt; &lt;javaModelGenerator targetPackage="$&#123;targetModelPackage&#125;" targetProject="$&#123;targetJavaProject&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!--自动生成的*Mapper.xml文件存放路径 举个例子：GoodsMapper.xml--&gt; &lt;sqlMapGenerator targetPackage="$&#123;targetXMLPackage&#125;" targetProject="$&#123;targetResourcesProject&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!--自动生成的*Mapper.java存放路径 举个例子：GoodsMapper.java--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="$&#123;targetMapperPackage&#125;" targetProject="$&#123;targetJavaProject&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 映射配置 上面生成的名称，开头都以domainObjectName命名的"TbgShop"开头--&gt; &lt;table tableName="goods" domainObjectName="Goods" &gt;&lt;/table&gt; &lt;table tableName="student" domainObjectName="Student" &gt;&lt;/table&gt; &lt;table tableName="user" domainObjectName="User" &gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 执行插件 运行之后，就可以生成相应的mapper，pojo和xml文件，文件夹会自动创建。]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pagehelper]]></title>
    <url>%2F2020%2F04%2F02%2F2020-04-01-Pagehelper%2F</url>
    <content type="text"><![CDATA[Pagehelper的使用 Pagehelper的使用SqlMapConfig.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--pageHelper版本5以前的配置--&gt; &lt;!--&lt;plugins&gt;--&gt; &lt;!-- &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt;--&gt; &lt;!-- &lt;property name="dialect" value="mysql"/&gt;--&gt; &lt;!-- &lt;/plugin&gt;--&gt; &lt;!--&lt;/plugins&gt;--&gt; &lt;!--pageHelper版本5以后的配置--&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt; &lt;property name="helperDialect" value="mysql"/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 依赖jar包 1234567891011&lt;!--mybatis分页相关的--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt; 设置分页信息 12345//获取第1页，10条内容，默认查询总数countPagehelper.startPage(1,10);//紧跟着的第一个select方法会被分页List&lt;User&gt; list=userMapper.selectIf(1); 获取分页信息有两种方法 第一种方法 123//分页后，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt;Page&lt;User&gt; userList=(Page&lt;User&gt;)list;userList.getTotal(); 第二种方法，推荐使用第二种 123456789101112131415//用PageInfo对结果进行包装PageInfo page=new PageInfo(list);//获取PageInfo全部属性，PageInfo包含了非常全面的分页属性assertEquals(1,page.getPageNum());assertEquals(10,page.getPageSize());assertEquals(1,page.getStartRow());assertEquals(10,page.getEndRow());assertEquals(183,page.getTotal());assertEquals(19,page.getPages());assertEquals(1,page.getFirstPage());assertEquals(8,page.getLastPage());assertEquals(true,page.isFirstPage());assertEquals(false,page.isLastPage());assertEquals(true,page.isHasNextPage());assertEquals(false,page.isHasPreviousPage()); java代码实践 12345678910111213141516171819202122public class DemoTest &#123; @Test public void testhelper() throws IOException &#123; //初始化spring容器 ApplicationContext context=new ClassPathXmlApplicationContext("classpath:spring/applicationContext.xml"); //获取mapper代理对象 UserMapper userMapper = context.getBean(UserMapper.class); //取出第一页，一页2个信息 PageHelper.startPage(1,2); UserExample example = new UserExample(); //去掉查询条件，是查询所有 //UserExample.Criteria criteria = example.createCriteria(); //criteria.andUseridEqualTo(1); List&lt;User&gt; users = userMapper.selectByExample(example); PageInfo&lt;User&gt; info=new PageInfo&lt;User&gt;(users); //Assert.assertEquals(info.getPages(),3,null)的使用，第一个参数是实际参数，第二个是期望参数，第3个是报错信息 //Assert.assertEquals(info.getPages(),3,null); System.out.println(info.getTotal()); &#125;&#125;]]></content>
      <categories>
        <category>Pagehelper</category>
      </categories>
      <tags>
        <tag>分布式案例</tag>
        <tag>Pagehelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02_Nginx做代理]]></title>
    <url>%2F2020%2F02%2F02%2F2020-02-02-02-Nginx%E5%81%9A%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[02_Nginx做代理 Ngnix做代理Nginx做静态资源的代理nginx做静态资源的代理有端口设置和域名绑定两种方式 端口设置 特点：一个服务就要配置一个端口 端口设置时一个端口就复制一个server。对server讲解如下： 我的虚拟机是：192.168.25.151，访问时访问：http://192.168.25.151:80/ ,指定访问80端口时，就去找对应的location，由于location的命名空间是/,所以会直接查找/usr/local/nginx文件夹下的html文件夹下的index.html文件 再配置一个81端口的服务，然后在/usr/local/nginx下创建一个文件夹hello，在该文件夹下创建一个文件hello.html,使用sudo ./nginx -s reload重新加载配置文件后，访问http://192.168.25.151:81/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546http &#123; include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; server &#123; #指定服务的端口 listen 80; #指定服务的名称，就是访问时的域名 server_name localhost; #执行端口后面要访问的html位置 location / &#123; #访问的文件夹 root html; #访问的该文件夹下的文件 index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 81; server_name localhost; location / &#123; root hello; index hello.html hello.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 域名绑定 特点：多个服务可以共用一个端口 其中的server_name就是指定的域名，我这里做测试，就用的SwitchHost配置的域名和ip对应。实际生产中需要购买域名和特定ip。访问时直接通过域名就可以访问。 123456789101112131415161718192021222324252627282930313233343536373839404142http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; #配置域名 server_name www.mynginx.com; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 80; #配置域名 server_name www.hello.com; location / &#123; root hello; index hello.html hello.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125; Nginx做动态代理反向代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253http &#123; include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; server &#123; #指定服务的端口 listen 80; #指定服务的名称，就是访问时的域名 server_name localhost; #执行端口后面要访问的html位置 location / &#123; #访问的文件夹 root html; #访问的该文件夹下的文件 index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; #动态代理的配置 upstream helloworld&#123; #这个是配置的反向代理的服务，一般是tomcat服务 server 192.168.25.151:8080; &#125; server &#123; listen 80; #这个就指向的upstream中的服务地址192.168.25.151:8080 proxy_pass http://helloworld; location / &#123; root hello; index hello.html hello.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 负载均衡多部署几个tomcat并配置进来就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657http &#123; include mime.types; default_type application/octet-stream; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; server &#123; #指定服务的端口 listen 80; #指定服务的名称，就是访问时的域名 server_name localhost; #执行端口后面要访问的html位置 location / &#123; #访问的文件夹 root html; #访问的该文件夹下的文件 index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; #动态代理的配置 upstream helloworld&#123; #这个是配置的反向代理的服务，一般是tomcat服务 #如果要让服务192.168.25.151:8180出现次数是其它的2倍，可以配置为： #server 192.168.25.151:8180 weight=2; server 192.168.25.151:8080; server 192.168.25.151:8180; server 192.168.25.151:8280; &#125; server &#123; listen 80; #这个就指向的upstream中的服务地址192.168.25.151:8080 proxy_pass http://helloworld; location / &#123; root hello; index hello.html hello.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01_Nginx的安装和启动]]></title>
    <url>%2F2020%2F02%2F02%2F2020-02-02-01-Nginx%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[01_Nginx的安装和启动 Nginx的安装和启动介绍两种安装方式 安装包安装安装Ngnix sudo apt-get install nginx 查看是否安装成功 nginx -V Ubuntu安装之后的文件结构大致为： 12345678910111213所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下主程序文件在/usr/sbin/nginx //可以使用which nginx查看全局配置文件/etc/nginx/nginx.conf日志放在了/var/log/nginx中，日志文件的位置可以在 /etc/nginx/nginx.conf文件中配置access_log /var/log/nginx/access.log; ## 访问日志文件路径名error_log /var/log/nginx/error.log; ## 访问日志文件错误路径名并已经在/etc/init.d/下创建了启动脚本nginx默认的虚拟主机的目录设置在了/var/www/nginx-default (有的版本 默认的虚拟主机的目录设置在了/var/www, 请参考/etc/nginx/sites-available里的配置) 启动Ngnix sudo /etc/init.d/nginx start 然后就可以访问了，http://localhost/ ， 一切正常！启动时候若显示端口80被占用：Starting nginx: [emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)，修改文件：/etc/nginx/sites-available/default,去掉 listen 前面的 # 号 , # 号在该文件里是注释的意思 , 并且把 listen 后面的 80 端口号改为自己的端口，访问是需要添加端口号。 源代码安装环境准备 12345678910#1.安装gcc g++的依赖库$ sudo apt-get install build-essential$ sudo apt-get install libtool#2.安装pcre依赖库$ sudo apt-get update$ sudo apt-get install libpcre3 libpcre3-dev#3.安装zlib依赖库$ sudo apt-get install zlib1g-dev#4.安装ssl依赖库$ sudo apt-get install openssl 安装Nginx 官网地址 123456# 下载1.8.0版本：sudo wget http://nginx.org/download/nginx-1.8.0.tar.gz# 解压：tar -zxvf nginx-1.8.0.tar.gz#进入解压目录：cd nginx-1.8.0 编译Nginx 创建Makefile文件 --prefix=/usr/local/nginx指向的是安装目录 1234567891011121314151617181920./configure \--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/tmp/nginx/client/ \--http-proxy-temp-path=/var/tmp/nginx/proxy/ \--http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \--http-scgi-temp-path=/var/tmp/nginx/scgi \#下面的配置可以不要--sbin-path=/usr/local/nginx/sbin/nginx \--conf-path=/usr/local/nginx/conf/nginx.conf \--user=nginx \--group=nginx \--with-http_ssl_module \--with-http_stub_status_module \--with-pcre 编译 1234#1.生成脚本和配置文件$ make#2.安装，安装的路径就是Makefile里的--prefix=/usr/local/nginx$ sudo make install 安装目录（/usr/local/nginx）下主要目录介绍 1234567conf：保存nginx所有的配置文件，其中nginx.conf是nginx服务器的最核心最主要的配置文件，其他的.conf则是用来配置nginx相关的功能的，例如fastcgi功能使用的是fastcgi.conf和fastcgi_params两个文件，配置文件一般都有个样板配置文件，是文件名.default结尾，使用的使用将其复制为并将default去掉即可。html目录中保存了nginx服务器的web文件，但是可以更改为其他目录保存web文件,另外还有一个50x的web文件是默认的错误页面提示页面。logs：用来保存nginx服务器的访问日志错误日志等日志，logs目录可以放在其他路径，比如/var/logs/nginx里面。sbin：保存nginx二进制启动脚本，可以接受不同的参数以实现不同的功能。 源代码安装的启动 123456789101112# 进入nginx下的sbin目录$ cd /usr/local/nginx/sbin # 创建--http-client-body-temp-path=/var/tmp/nginx/client/ 执行的目录$ mkdir /var/tmp/nginx/client/ -p# 启动$ sudo ./nginx# 停止$ sudo ./nginx -s stop# 进行一些配置更改后重新加载$ sudo ./nginx -s reload# 查看进程$ ps aux | grep nginx 使用systemctl管理Nginx服务 使用安装包安装的可以直接使用systemctl管理Nginx服务，但是使用源代码安装的需要配置 您可以像任何其他systemd单位一样管理Nginx服务。 要停止Nginx服务，请运行： 1$ sudo systemctl stop nginx 要再次启动，请键入： 1$ sudo systemctl start nginx 重新启动Nginx服务： 1$ sudo systemctl restart nginx 在进行一些配置更改后重新加载Nginx服务： 1$ sudo systemctl reload nginx 如果你想禁用Nginx服务在启动时启动： 1$ sudo systemctl disable nginx 并重新启用它： 1$ sudo systemctl enable nginx 使用源代码安装的Nginx配置systemctl管理Nginx.service 创建配置文件 12# 源码安装的nginx在/etc/systemd/system/multi-user.target.wants/目录下是没有nginx.service这个文件的，所以要新建。但是我在systemd下并没有看到system（Ubuntu18.04.3），这个后续再研究$ vim /usr/lib/systemd/system/nginx.service 写入内容 123456789101112131415[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network-online.target remote-fs.target nss-lookup.targetWants=network-online.target[Service]Type=forkingPIDFile=/var/run/nginx/nginx.pidExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s TERM $MAINPID[Install]WantedBy=multi-user.target 设置开机启动 1$ sudo systemctl enable nginx.service 关闭之前启动的nginx服务 1$ pkill -9 nginx 重载修改过的所有配置文件 1$ sudo systemctl daemon-reload 重新启动nginx服务 1$ sudo systemctl start nginx Ubuntu下卸载nginx先停止nginx服务 1$ sudo systemctl stop nginx 删除nginx，–purge包括配置文件 1$ sudo apt-get --purge remove nginx 自动移除全部不使用的软件包 1$ sudo apt-get autoremove 列出与nginx相关的软件 并删除显示的软件 12345$ dpkg --get-selections|grep nginx$ sudo apt-get --purge remove nginx$ sudo apt-get --purge remove nginx-common$ sudo apt-get --purge remove nginx-core 再次执行 123$ dpkg --get-selections|grep nginx$ which nginx #不再显示nginx]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中使用json-server]]></title>
    <url>%2F2020%2F01%2F12%2F2020-01-12-Vue%E4%B8%AD%E4%BD%BF%E7%94%A8json-server%2F</url>
    <content type="text"><![CDATA[Vue中使用json-server Vue中使用json-server安装json-server全局安装 1npm install -g json-server 局部安装 1npm install --save json-server 提供json数据文件 在项目根目录下，新建一个 JSON 文件db.json 1234567&#123; "student": [ &#123;"id":1, "name":"zhangsan"&#125;, &#123;"id":2, "name":"lisi"&#125;, &#123;"id":3, "name":"wangwu"&#125; ]&#125; 配置json-server 在build\webpack.dev.conf.js下配置 1234567891011121314/*----------------jsonServer---------*//*引入json-server*/const jsonServer = require('json-server')/*搭建一个server*/const apiServer = jsonServer.create()/*将db.json关联到server*/const apiRouter = jsonServer.router('db.json')const middlewares = jsonServer.defaults()apiServer.use(middlewares)apiServer.use(apiRouter)/*监听端口*/apiServer.listen(3000, () =&gt; &#123; console.log('JSON Server is running')&#125;) 访问数据 配置完成后，要npm dev run 重启项目，然后再地址栏输入http://localhost:3000 就可以访问到数据。 设置代理 最后做一下浏览器代理设置，因为json-server的访问端口是3000，Vue的访问端口是8000，为了使用json-server时端口也用8000，所以设置一下代理。在 config/index.js中 1234567891011/*代理配置表，在这里可以配置特定的请求代理到对应的API接口*//* 下面的例子将代理请求 /api/student 到 http://localhost:3000/student*/proxyTable: &#123; '/api': &#123; changeOrigin: true,// 如果接口跨域，需要进行这个参数配置 target: 'http://localhost:3000',// 接口的域名 pathRewrite: &#123; '^/api': ''//后面可以使重写的新路径，一般不做更改 &#125; &#125;&#125; 验证代理是否成功 在浏览器输入地址：http://localhost:8080/api/ Vue中 使用 使用vue-resouce发送Ajax获取数据 123456this.$http.get('/api/student')//代替http://localhost:3000/student .then((res) =&gt; &#123; this.newsList = res.data &#125;, (err) =&gt; &#123; console.log(err) &#125;)]]></content>
      <categories>
        <category>json-server</category>
      </categories>
      <tags>
        <tag>json-server</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json-server]]></title>
    <url>%2F2020%2F01%2F12%2F2020-01-12-json-server%2F</url>
    <content type="text"><![CDATA[json-server入门 json-serverhttp-server用于模拟http请求，安装 1$ npm i http-server -g 查看是否安装完成。其中的hs是http-server的简写 123456789$ hs -VStarting up http-server, serving ./Available on: http://192.168.31.235:8080 http://192.168.120.1:8080 http://88.88.88.1:8080 http://192.168.25.1:8080 http://127.0.0.1:8080Hit CTRL-C to stop the server 启动http-server。其中的-o意思是启动时打开浏览器 123456789$ hs -oStarting up http-server, serving ./Available on: http://192.168.31.235:8080 http://192.168.120.1:8080 http://88.88.88.1:8080 http://192.168.25.1:8080 http://127.0.0.1:8080Hit CTRL-C to stop the server RESTful API 面向资源编程 地址即资源 所有的东西都是资源，所有操作都通过对资源的增删改查实现 对资源的增删改查对应URL的操作分别是POST,DELETE,PUT,GET 如果要测试POST,DELETE,PUT，使用postman即可，浏览器只能查询 1234http://localhost:8080/users -&gt; 所有的用户数据http://localhost:8080/products -&gt; 所有的产品数据http://localhost:8080/users/1/name -&gt; 编号为1的用户的名称http://localhost:8080/products/iphone-&gt; 特指iphone这个商品 第三方模拟数据工具 mock.js:无法持久化数据。 http://mockjs.com/ mock的使用文档： http://mockjs.com/examples.html mock拦截请求，返回假数据的方法 123456//1.引入mock.js文件//2.使用Mock.mock()//3个参数。'/users'：拦截http://localhost:8080/users的请求；'get'：拦截的请求方式是get方式；&#123;hello:'mock.js'&#125;：返回的假数据 Mock.mock('/users','get',&#123; hello:'mock.js'&#125;) json-server json-server安装json-server 1$ npm install -g json-server 启动json-server。其中的db.json是数据文件 1$ json-server --watch db.json json-server基本特性具体的基本特性使用方式参考：https://github.com/typicode/json-server db.json测试数据库，访问地址： http://localhost:3000/student 1234567&#123; "student": [ &#123;"id":1, "name":"zhangsan"&#125;, &#123;"id":2, "name":"lisi"&#125;, &#123;"id":3, "name":"wangwu"&#125; ]&#125; 标准的RESTful API 支持过滤，访问地址： http://localhost:3000/student?q=zhangsan 123456[ &#123; "id": 1, "name": "zhangsan" &#125;] 支持分页,访问地址：http://localhost:3000/student?_limit=2&amp;_page=1。意思是访问第一页page，该页显示两条数据 12345678910[ &#123; "id": 1, "name": "zhangsan" &#125;, &#123; "id": 2, "name": "lisi" &#125;] 支持排序 支持全文检索 支持关系 支持数据分割 支持操作符（大于小于） 支持JSONP 支持CORS]]></content>
      <categories>
        <category>json-server</category>
      </categories>
      <tags>
        <tag>json-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git配置多个ssh-key]]></title>
    <url>%2F2020%2F01%2F03%2F2020-01-02-git%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key%2F</url>
    <content type="text"><![CDATA[git配置多个ssh-key git配置多个ssh-key 我们在工作当中，经常遇到自己有个gitlab账号，然而公司也有个gitlab账号，或者再有个github账号，或者gitee账号，这么多的账号，每次拉取项目都是个很麻烦的问题，因为需要配置多个ssh-key来管理。 生成公司和个人的ssh-key1234#生成公司的ssh-key$ ssh-keygen -t rsa -C 'youremail@yourcompany.com' -f ~/.ssh/gitlab_company_rsa#生成个人的ssh-key$ ssh-keygen -t rsa -C 'youremail@your.com' -f ~/.ssh/gitlab_myself_rsa 生成公司的ssh-key 123456789101112131415161718192021$ ssh-keygen -t rsa -C 'wanghui_isf@si-tech.com.cn' -f ~/.ssh/gitlab_company_rsaGenerating public/private rsa key pair.Created directory '/c/Users/wanghui/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/wanghui/.ssh/gitlab_company_rsa.Your public key has been saved in /c/Users/wanghui/.ssh/gitlab_company_rsa.pub.The key fingerprint is:SHA256:wPCl9enJ2v43bFr3ZeMQuAP9o9An8jzSiCI8/XRfnso wanghui_isf@si-tech.com.cnThe key's randomart image is:+---[RSA 3072]----+| . o || + + . . || = o || . o... || S.+o . || oo o . || . . .o++= B..+|| + o...+BoB.Xo+|| o o. oE=* o.|+----[SHA256]-----+ 生成个人的ssh-key 1234567891011121314151617181920$ ssh-keygen -t rsa -C 'emcderm2@students.solano.edu' -f ~/.ssh/gitlab_myself_rsaGenerating public/private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/wanghui/.ssh/gitlab_myself_rsa.Your public key has been saved in /c/Users/wanghui/.ssh/gitlab_myself_rsa.pub.The key fingerprint is:SHA256:jqYu2k9TddzlwpNLzvXXkJBfhldXbaZzsPsiLz7P4JQ emcderm2@students.solano.eduThe key's randomart image is:+---[RSA 3072]----+| ....B|| . o.=o.O|| . o B.=X || . . + ==oo|| . S + ++|| . o .. .|| o o . E . || ... + o+o. .||...++ .o*+. |+----[SHA256]-----+ 查看公司和个人的ssh-key 1234#查看公司的ssh-key$ cat /c/Users/wanghui/.ssh/gitlab_company_rsa.pub#查看个人的ssh-key$ cat /c/Users/wanghui/.ssh/gitlab_myself_rsa.pub 添加ssh-key到gitlab中 添加私钥1234$ ssh-agent bash$ ssh-add ~/.ssh/gitlab_company_rsa$ ssh-add ~/.ssh/gitlab_myself_rsa$ ssh-add -l 备注：如果ssh-add ~/.ssh/gitlab_company_rsa不行，就改成ssh-add ~/.ssh/gitlab_company.rsa 具体操作 123456789101112131415wanghui@DESKTOP-H6A9OVE MINGW64 /c/wanghui/persion/blog (master)$ ssh-agent bashwanghui@DESKTOP-H6A9OVE MINGW64 /c/wanghui/persion/blog (master)$ ssh-add ~/.ssh/gitlab_company_rsaIdentity added: /c/Users/wanghui/.ssh/gitlab_company_rsa (wanghui_isf@si-tech.com.cn)wanghui@DESKTOP-H6A9OVE MINGW64 /c/wanghui/persion/blog (master)$ ssh-add ~/.ssh/gitlab_myself_rsaIdentity added: /c/Users/wanghui/.ssh/gitlab_myself_rsa (emcderm2@students.solano.edu)wanghui@DESKTOP-H6A9OVE MINGW64 /c/wanghui/persion/blog (master)$ ssh-add -l3072 SHA256:wPCl9enJ2v43bFr3ZeMQuAP9o9An8jzSiCI8/XRfnso wanghui_isf@si-tech.com.cn (RSA)3072 SHA256:jqYu2k9TddzlwpNLzvXXkJBfhldXbaZzsPsiLz7P4JQ emcderm2@students.solano.edu (RSA) 创建config文件文件所在路径 ~/.ssh，配置信息 123456789101112# gitlab_companyHost git.si-tech.com.cn HostName git.si-tech.com.cn User git PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_company_rsa# gitlab_myselfHost gitlab.com HostName gitlab.com User git PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_myself_rsa config配置文件讲解,以公司ssh-key为例 123456# gitlab_companyHost git.si-tech.com.cn HostName git.si-tech.com.cn User git PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_company_rsa 例如拉取的项目是：`git@git.si-tech.com.cn:chengwei/woapp-dev.git` 配置文件User+HostName = git@git.si-tech.com.cn 其中 User = git HostName = git@git.si-tech.com.cn 验证1234#验证公司的是否连接$ ssh -T git@git.si-tech.com.cn#验证个人的是否连接$ ssh -T git@gitlab.com 如果连接，会显示出用户名]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh-key</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[activiti_组和网关]]></title>
    <url>%2F2020%2F01%2F03%2F2020-01-02-activiti-%E7%BB%84%E5%92%8C%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[activiti_组和网关 组任务设置任务执行的候选人 组任务办理流程 第一步：查询组任务 指定候选人，查询该候选人当前的待办任务 候选人不能办理任务（拾取后才能办理） 第二步：拾取（claim）任务 该组任务的所有候选人都能拾取 将候选人的组任务，变成个人任务。原来候选人就变成了该任务的负责人 如果拾取任务后不想办理该任务，需要将已经拾取的个人任务归还到组里面，将个人任务变成了组任务 第三步：查询个人任务 查询方式同个人任务部分，根据assignee查询用户负责的个人任务 第四步：办理个人任务 组任务的拾取、归还、交接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/***act_ru_task*act_ru_identitylink*act_hi_identitylink*///得到TaskService对象TaskService taskService=processEngine.getTaskService();//设置一些参数，流程定义的key，候选用户String key="myProcess_1";//候选人String candidate_users="zhangsan";//执行查询 根据流程定义和候选用户查询Task task=taskService.createTaskQuery() .processDefinitionKey(key) .taskCandidateUser(candidate_users) .singleResult();//输出查询结果,这个是按照list查询得到的// for (Task task:list)&#123;// System.out.println(task.getProcessDefinitionId());// System.out.println(task.getId());// System.out.println(task.getName());// //task.getAssignee()为null，说明zhangsan目前只是任务的候选人，还不是任务的执行人// System.out.println(task.getAssignee());// &#125;//让zhangsan来拾取任务if(task!=null)&#123; //第一个参数是任务id，第二个参数是具体的候选用户名 taskService.claim(task.getId(),candidate_users); System.out.println("任务拾取完毕");&#125;//任务拾取完毕后，候选人就成为了任务的执行人，执行任务...//如果候选人不想执行任务了，可以归还任务//先检验userId是否是taskId的负责人，如果是负责人才可以归还任务String taskId=task.getId();String userId="zhangsan";Task task1=taskService.createTaskQuery() .taskId(taskId) .taskAssignee(userId) .singleResult();//归还或者交接任务if (task1!=null)&#123; //第二个参数为null是归还任务 taskService.setAssignee(taskId,null); //第二个参数指定具体的人为交接任务给别人 taskService.setAssignee(taskId,"lisi");&#125;&#125; 网关排他网关 如果一个是num&gt;3,流程结点id=_5。一个是num&gt;=1,流程结点id=_7。这时如果传的流程变量是5。就会走id=_5的结点，走结点数字小的那个。 注意:如果条件都不满足，排他网关会报错。例如前面的例子传的流程变量是0。 排他网关的目的:当多个条件都达到满足的条件时，会一定选择一个来走，按照id小的来选择 并行网关 作用:使用了并行网关后，接下来的分支都要执行。当所有的分支执行结束后，使用并行网关合并到一起，完全合并结束后，才会执行后面的流程 注意:并行网关会忽视设置的条件 包含网关 作用:具有排他网关的设置条件功能和并行网关的同时走多个分支的功能。包含网关和并行网关的区别在于，并行网关会忽视设置的条件，但包含网关不会，并行网关后面的分支都要走，包含网关只有满足条件的所有分支 注意:包含网关也要有分支和汇聚。如果包含网关中设置的条件都不满足，会报异常]]></content>
      <categories>
        <category>activiti</category>
      </categories>
      <tags>
        <tag>工作流</tag>
        <tag>activiti</tag>
        <tag>组任务</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acticiti_任务分配和流程变量]]></title>
    <url>%2F2020%2F01%2F02%2F2020-01-02-acticiti-%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E5%92%8C%E6%B5%81%E7%A8%8B%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[acticiti_任务分配和流程变量 任务分配UEL表达式分配任务需求：真实环境中bpmn中的执行人是不能写死的，可以使用UEL表达式占位符 如果是对象可以写成${user.assiginee0}。其中的user是一个对象 1234567891011/*UEL表达式*/Map&lt;String,Object&gt; variables=new HashMap&lt;&gt;();//assiginee0、assiginee1、assiginee2分别对应bpmn中执行流程的assigineevariables.put("assiginee0","zhangsan");variables.put("assiginee1","lisi");variables.put("assiginee2","wangwu");runtimeService.startProcessInstanceByKey("test",variables);//输出System.out.println(processEngine.getName()); 监听器分配任务 Create：任务创建后触发 Assignment：任务分配后触发 Delete：任务完成后触发 All：所有事件发生都触发 监听器分配任务方式：1.编写要监听的类实现TaskListener 2.在bpmn中设置这个类 123456789101112package com.hui.table;import org.activiti.engine.delegate.DelegateTask;import org.activiti.engine.delegate.TaskListener;public class MyListener implements TaskListener &#123; @Override public void notify(DelegateTask delegateTask) &#123; //指定任务负责人 delegateTask.setAssignee("zhangsan"); &#125;&#125; 流程变量流程变量的作用域流程变量默认作用于一个流程实例，称为Global变量。也可以作用于一个结点，称为Local变量 Global变量：变量名不可以相同，否则后面设置的会覆盖掉前面设置的 Local变量：变量名可以相同，因为作用域互不影响 Global流程变量的使用流程变量直接点击连接然后在Condition中设置条件即可。图中是对象的形式设置的。如果不是对象，直接num&lt;=3设置即可 实体类的创建 1234567891011121314/** * 请假实体类 * 注意：如果是pojo类型存储到流程变量中，一定要实现Serializable */@Datapublic class Test0 implements Serializable &#123; private Integer id; private String testName; //申请人名称 private Date beginDate; //开始日期 private Date enddate; //结束日期 private Float num; //请假天数 private String reason; //请假事由 private String type; //请假类型&#125; 启动流程携带流程变量123456789101112131415161718/*流程启动时携带变量信息Test0对象存到了act_ru_variable表中流程变量存到了act_ge_bytearray*///1.得到运行实例RuntimeService runtimeService = processEngine.getRuntimeService();//2.这次根据key来启动 得到key，获取方法前面结束的有String key="myProcess_1";//3.设置流程实例变量Test0 test0=new Test0();test0.setNum(1F);Map&lt;String,Object&gt; variables=new HashMap&lt;&gt;();ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(key, variables);//打印看一下结果System.out.println(processInstance.getName());System.out.println(processInstance.getProcessDefinitionId()); 任务办理后携带流程变量123456789101112131415161718192021/*任务办理时携带变量信息Test0对象存到了act_ru_variable表中流程变量存到了act_ge_bytearray*///1.得到任务实例TaskService taskService = processEngine.getTaskService();//2.得到key，获取方法前面介绍的有String key="myProcess_1";//3.查询当前任务实例是否有任务Task task = taskService.createTaskQuery().processDefinitionKey(key) .taskAssignee("wangwu").singleResult();//4.设置流程实例变量Test0 test0=new Test0();test0.setNum(1F);Map&lt;String,Object&gt; variables=new HashMap&lt;&gt;();if (task!=null)&#123; taskService.complete(task.getId(),variables); System.out.println("任务执行完成");&#125; 通过当前流程设置流程变量1234567891011121314151617181920/*通过当前流程设置流程变量Test0对象存到了act_ru_variable表中流程变量存到了act_ge_bytearray*///1.得到运行实例RuntimeService runtimeService = processEngine.getRuntimeService();//2.设置流程实例变量的值Test0 test0=new Test0();test0.setNum(1F);//第一个参数是流程实例id，2501是流程实例id//第二个参数是bpmn文件里设置的流程变量的名称$&#123;test0.num&#125;，因为是对象，所在这里写对象的名称//第三个值是流程变量的值，就是上面创建对象，赋值后的test0//这种一次只能设置一个值runtimeService.setVariable("2501","test0",test0);//这种可以一次设置多个值。variables是个map集合//runtimeService.setVariable("2501",variables); 通过当前任务设置流程变量注意：任务taskId必须是当前待办任务id。act_ru_task表中存在，如果任务已结束，会报错。 1234567891011121314151617181920/*通过当前任务设置流程变量信息Test0对象存到了act_ru_variable表中流程变量存到了act_ge_bytearray*///1.得到运行实例TaskService taskService = processEngine.getTaskService();//2.设置流程实例变量的值Test0 test0=new Test0();test0.setNum(1F);//第一个参数是任务taskId//第二个参数是bpmn文件里设置的流程变量的名称$&#123;test0.num&#125;，因为是对象，所在这里写对象的名称//第三个值是流程变量的值，就是上面创建对象，赋值后的test0//这种一次只能设置一个值taskService.setVariable("1404","test0",test0);//这种可以一次设置多个值。variables是个map集合//taskService.setVariable("1404",variables); Local流程变量的使用代码和Global的使用方式一样，唯一不同的是setVariableLocal 1taskService.setVariableLocal("1404","test0",test0);]]></content>
      <categories>
        <category>activiti</category>
      </categories>
      <tags>
        <tag>工作流</tag>
        <tag>activiti</tag>
        <tag>任务分配</tag>
        <tag>流程变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[activiti入门02]]></title>
    <url>%2F2020%2F01%2F02%2F2020-01-02-activiti%E5%85%A5%E9%97%A802%2F</url>
    <content type="text"><![CDATA[activiti入门02 使用zip格式文件部署12345678910111213141516/*zip格式文件的部署虽然部署上去的是zip文件，但是在表格中会给自动解压*///GenerateActivitiTable这个是自己定义的类 test.zip为把bpmn和png文件压缩成的zip格式文件InputStream is = GenerateActivitiTable.class.getClassLoader().getResourceAsStream("/process/test.zip");//将InputStream流转化为ZipInputStream流ZipInputStream zipInputStream=new ZipInputStream(is);//部署Deployment deploymentZip = repositoryService.createDeployment() .addZipInputStream(zipInputStream) .name("请假流程审批") //设置名称 .deploy();//输出部署信息 act_re_deployment表中System.out.println(deploymentZip.getName());System.out.println(deploymentZip.getId()); 流程定义流程定义的查询和删除1234567891011121314151617181920212223242526272829/*流程定义的查询 查询表act_re_procdef:(流程定义的信息)，发布的流程都在这里，每一个流程就是每一张图*///得到ProcessDefinitionQuery对象，可以认为是一个查询器ProcessDefinitionQuery processDefinitionQuery=repositoryService.createProcessDefinitionQuery();List&lt;ProcessDefinition&gt; processDefinitionList = processDefinitionQuery.processDefinitionKey("test") //指定查询哪一个流程.orderByProcessDefinitionVersion() //指定该流程定义的排序规则。按版本号.desc().list();//降序Listfor (ProcessDefinition processDefinition:processDefinitionList)&#123;System.out.println("流程定义ID:"+processDefinition.getId());System.out.println("流程定义名称:"+processDefinition.getName());System.out.println("流程定义的key:"+processDefinition.getKey());System.out.println("流程定义的版本号:"+processDefinition.getVersion());/*流程的删除，根据流程部署id删除.影响的表和部署的表一样注意：当正在执行的流程没有完全执行完后，执行删除会失败。例如：流程只走到了部门经理审批，这时候是不能删除流程如果还想删除，可以设置级联删除act_re_procdef:(流程定义的信息)act_ge_bytearray：(流程定义的文件)act_re_deployment：(部署信息)*/System.out.println("流程部署的ID:"+processDefinition.getDeploymentId());repositoryService.deleteDeployment(processDefinition.getDeploymentId());//设置级联删除，即使流程未走完，也给删除掉//repositoryService.deleteDeployment(processDefinition.getDeploymentId(),true); 流程定义资源的读取需求：从act_ge_bytearray表中读取bpmn文件和png文件 方法： 使用activiti的api 使用原理层面，可以使用jdbc的blob、clob类型数据的读取，并保存 IO流转换，最好使用commons-io.jar包轻松处理IO 实现方式 1234567891011121314151617181920212223242526/*获取act_ge_bytearray里的bpmn和png资源*///1.获取流程部署ID。通过流程定义的查询可以查出流程部署的IDString deployId=processDefinition.getDeploymentId();//2.通过repositoryService读取bpmn和png信息(输入流)//getResourceAsStream有两个参数：第一个是部署id，第二个是资源名称//processDefinition.getDiagramResourceName()是png图片的名称test.pngInputStream pngIs=repositoryService .getResourceAsStream(deployId,processDefinition.getDiagramResourceName());//processDefinition.getResourceName()是bpmn文件的名称test.bpmnInputStream bpmnIs=repositoryService .getResourceAsStream(deployId,processDefinition.getResourceName());//3.构建出OutputStream输出流OutputStream pngOs =new FileOutputStream("C:\\wanghui\\resources"+processDefinition.getDiagramResourceName());OutputStream bpmnOs =new FileOutputStream("C:\\wanghui\\resources"+processDefinition.getResourceName());//4.使用common-io实现输入流、输出流的转换IOUtils.copy(pngIs,pngOs);IOUtils.copy(bpmnIs,bpmnOs);//5.关流pngOs.close();bpmnOs.close();pngIs.close();bpmnIs.close(); 历史信息的查询123456789101112131415161718//历史管理类HistoryService historyService = processEngine.getHistoryService();/*查询历史记录，从act_hi_actinst表中查*///得到查询对象HistoricActivityInstanceQueryHistoricActivityInstanceQuery historicActivityInstanceQuery = historyService.createHistoricActivityInstanceQuery();//设置要查询的实例：2502是实例的id，查询方法前面已有介绍historicActivityInstanceQuery.processInstanceId("2502");List&lt;HistoricActivityInstance&gt; list = historicActivityInstanceQuery.orderByHistoricActivityInstanceStartTime().asc() //根据时间排序.list();for (HistoricActivityInstance instance:list)&#123;System.out.println("流程结点Id:"+instance.getActivityId());System.out.println("流程结点名称:"+instance.getActivityName());System.out.println("流程定义的Id:"+instance.getProcessDefinitionId());System.out.println("流程实例的Id:"+instance.getProcessInstanceId());&#125; businessKey为了让activiti和业务相结合，在表act_ru_execution中有个BUSINESSKEY字段，这样可以把业务和流程分开，如果要执行zhangsan的流程，只需要把zhangsan的businessKey入act_ru_execution表 1234567//流程运行管理类RuntimeService runtimeService = processEngine.getRuntimeService();//这里的key就是流程定义bpmn文件起的id名称//1001是业务系统中的businessKey//启动流程时把1001入到businessKeyProcessInstance test = runtimeService.startProcessInstanceByKey("test","1001");System.out.println("获取存入到表中的businessKey："+test.getBusinessKey()); 挂起和激活需求：如果公司制度修改，未执行完的流程怎么处理？这时可以让流程挂起或者激活。 流程定义的挂起和激活如果流程定义挂起，则不能再执行流程实例，而且其下的所有流程实例都是挂起状态 12345678910111213141516171819/*流程定义的挂起和激活*///查询流程定义的对象ProcessDefinition processDefin = repositoryService.createProcessDefinitionQuery() .processDefinitionKey("test").singleResult();//得到当前流程的实例是否都为暂停状态.ture是暂停boolean suspended = processDefin.isSuspended();String processDefinitionId = processDefin.getId();//判断if (suspended)&#123; //说明是暂停，可以使用激活操作 repositoryService.activateProcessDefinitionById(processDefinitionId,true,null); System.out.println("流程定义："+processDefinitionId+"：激活");&#125;else &#123; //挂起 repositoryService.suspendProcessDefinitionById(processDefinitionId,true,null); System.out.println("流程定义："+processDefinitionId+"：挂起");&#125; 流程实例的挂起和激活挂起状态再执行流程，会抛出异常 12345678910111213141516171819/*流程实例的挂起和激活*///查询流程定义的对象ProcessInstance processInstance = runtimeService.createProcessInstanceQuery() .processInstanceId("2501").singleResult(); //2501是实例id//得到当前流程的实例是否都为暂停状态.ture是暂停boolean suspended = processInstance.isSuspended();String processInstanceId = processInstance.getId();//判断if (suspended)&#123; //说明是暂停，可以使用激活操作 runtimeService.activateProcessInstanceById(processInstanceId); System.out.println("流程实例："+processInstanceId+"：激活");&#125;else &#123; //挂起 runtimeService.suspendProcessInstanceById(processInstanceId); System.out.println("流程实例："+processInstanceId+"：挂起");&#125;]]></content>
      <categories>
        <category>activiti</category>
      </categories>
      <tags>
        <tag>工作流</tag>
        <tag>activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[activiti入门01]]></title>
    <url>%2F2019%2F12%2F31%2F2019-12-31-activiti%E5%85%A5%E9%97%A801%2F</url>
    <content type="text"><![CDATA[activiti入门01 什么是工作流工作流：工作的一个流程，事物发展的一个业务过程 例子： 请假流程：开始—-员工申请—-部门经理审批—-总经理审批—-结束 activiti的表的生成依赖的pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;6.0.S&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;6.0.S&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt; &lt;version&gt;6.0.S&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-bpmn-converter&lt;/artifactId&gt; &lt;version&gt;6.0.S&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt; &lt;version&gt;6.0.S&lt;/version&gt; &lt;/dependency&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.activiti&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;activiti-bpmn-layout&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;6.0.S&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt;&lt;!-- &lt;dependency&gt;--&gt;&lt;!-- &lt;groupId&gt;org.activiti.cloud&lt;/groupId&gt;--&gt;&lt;!-- &lt;artifactId&gt;activiti-cloud-services-api&lt;/artifactId&gt;--&gt;&lt;!-- &lt;version&gt;6.0.S&lt;/version&gt;--&gt;&lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; activiti.cfg.xml文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="jdbc:mysql://localhost:3306/db_activiti" /&gt; &lt;property name="url" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/bean&gt; &lt;!--StandaloneProcessEngineConfiguration是脱机方式--&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!--是否生成表结构--&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;/bean&gt;&lt;/beans&gt; 生成表1234567891011/*创建表*///1.创建ProcessEngineConfiguration对象ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml");//2.创建ProcessEngine对象ProcessEngine processEngine = configuration.buildProcessEngine();//3.输出一下processEngineSystem.out.println(processEngine); 表结构介绍 ACT_GE_* : “GE”代表“General”（通用），用在各种情况下； ACT_HI_* : “HI”代表“History”（历史），这些表中保存的都是历史数据，比如执行过的流程实例、变量、任务，等等。Activit默认提供了4种历史级别： none: 不保存任何历史记录，可以提高系统性能； activity：保存所有的流程实例、任务、活动信息； audit：也是Activiti的默认级别，保存所有的流程实例、任务、活动、表单属性； full：最完整的历史记录，除了包含audit级别的信息之外还能保存详细，例如：流程变量。 对于几种级别根据对功能的要求选择，如果需要日后跟踪详细可以开启full。 ACT_ID_* : “ID”代表“Identity”（身份），这些表中保存的都是身份信息，如用户和组以及两者之间的关系。如果Activiti被集成在某一系统当中的话，这些表可以不用，可以直接使用现有系统中的用户或组信息； ACT_RE_* : “RE”代表“Repository”（仓库），这些表中保存一些‘静态’信息，如流程定义和流程资源（如图片、规则等）； ACT_RU_* : “RU”代表“Runtime”（运行时），这些表中保存一些流程实例、用户任务、变量等的运行时数据。Activiti只保存流程实例在执行过程中的运行时数据，并且当流程结束后会立即移除这些数据，这是为了保证运行时表尽量的小并运行的足够快； avtiviti数据表清单 表分类 表名 解释 一般数据 ACT_GE_BYTEARRAY 通用的流程定义和流程资源 ACT_GE_PROPERTY 系统相关属性 浏览历史记录 ACT_HI_ACTINST 历史的流程实例 ACT_HI_ATTACHMENT 历史的流程附件 ACT_HI_COMMENT 历史的说明性信息 ACT_HI_DETAIL 历史的流程运行中的细节信息 ACT_HI_IDENTITYLINK 历史的流程运行过程中用户关系 ACT_HI_PROCINST 历史的流程实例 ACT_HI_TASKINST 历史的任务实例 ACT_HI_VARINST 历史的流程运行中的变量信息 用户用户组表 ACT_ID_GROUP 身份信息-组信息 ACT_ID_INFO 身份信息-组信息 ACT_ID_MEMBERSHIP 身份信息-用户和组关系的中间表 ACT_ID_USER 身份信息-用户信息 流程定义表 ACT_RE_DEPLOYMENT 部署单元信息 ACT_RE_MODEL 模型信息 ACT_RE_PROCDEF 已部署的流程定义 运行实例表 ACT_RU_EVENT_SUBSCR 运行时事件 ACT_RU_EXECUTION 运行时流程执行实例 ACT_RU_IDENTITYLINK 运行时用户关系信息 ACT_RU_JOB 运行时作业 ACT_RU_TASK 运行时任务 ACT_RU_VARIABLE 运行时变量表 activiti流程定义任何一个流程都有一个id和name 定义请假流程的执行人 流程图的底层原理 业务流程图本质是一个xml文件，文件中可以存入所需要的数据 读取业务流程图的过程就是解析xml的过程 读取一个业务流程图的结点就相当于解析一个xml结构，进一步将数据插入到mysql表中，形成一条记录 将所有结点读取并存入mysql表中 后面只需要读mysql表中的记录就可以了，读一条记录将相当于读一个结点 业务流程的推进，后面就转化为读表中数据，并且处理数据，结束时这一行数据就可以删除。 常用的4个对象 资源管理类：RepositoryService 流程运行管理类：RuntimeService 任务管理类：TaskService 历史管理类：HistoryService 流程部署12345678910111213141516//资源管理类RepositoryService repositoryService = processEngine.getRepositoryService();/*将资源部署到数据库中 影响表act_re_procdef:(流程定义的信息)。存的是key和name，就是画图时给每张图起的唯一的名称act_ge_bytearray：(流程定义的文件)。bpmn和png资源就存在这张表中act_re_deployment：(部署信息)。部署时写的name("请假流程审批")存在这张表中*/Deployment deployment = repositoryService.createDeployment().addClasspathResource("process/test.bpmn").addClasspathResource("process/test.png").name("请假流程审批") //设置名称.deploy();//输出部署信息 act_re_deployment表中System.out.println(deployment.getName());System.out.println(deployment.getId()); 流程运行12345678910111213141516171819//流程运行管理类RuntimeService runtimeService = processEngine.getRuntimeService();/*启动流程实例。前提必须已经完成了部署 影响表act_hi_actinst:(已完成的活动信息)。表中开始按钮已经执行，但是zhangsan还未执行请假申请。看END_TIME字段act_hi_identitylink:(参与者信息)。参与者，目前只记录一个zhangsanact_hi_procinst:(流程实例)。目前只记录一个zhangsanact_hi_taskint:(任务实例)。任务表，有个zhangsan需要填写请假申请单的任务act_ru_execution:(执行表)。记录任务的执行act_ru_identitylink:(参与者信息)。任务的参与者act_ru_task:(任务)。记录当前任务*/ProcessInstance test = runtimeService.startProcessInstanceByKey("test");//这里的key就是流程定义bpmn文件起的id名称//打印一下结果System.out.println("流程部署ID:"+test.getDeploymentId()); //nullSystem.out.println("流程定义ID:"+test.getProcessDefinitionId()); //test:1:4System.out.println("流程实例ID:"+test.getId()); //2501。流程实例:zhangsan可以有实例，其他人也可以有实例System.out.println("活动ID:"+test.getActivityId()); //null 任务查询和处理12345678910111213141516171819202122232425262728293031//任务管理类TaskService taskService = processEngine.getTaskService();/*任务查询流程实例ID：来自表act_hi_procinst任务ID、任务负责人，任务名称：来自表act_hi_taskint*/List&lt;Task&gt; taskList = taskService.createTaskQuery().processDefinitionKey("test") //这里的key就是流程定义bpmn文件起的id名称，指定哪个流程.taskAssignee("zhangsan") //指定任务的处理人.list(); //.singleResult()可以只查询一条任务//任务列表的展示for (Task task:taskList)&#123;System.out.println("流程实例ID:"+task.getProcessInstanceId());System.out.println("任务ID:"+task.getId());System.out.println("任务负责人:"+task.getAssignee());System.out.println("任务名称:"+task.getName());/*任务处理 影响表act_hi_actinst:(已完成的活动信息)act_hi_identitylink:(参与者信息)act_hi_taskint:(任务实例)act_ru_execution:(执行表)act_ru_identitylink:(参与者信息)act_ru_task:(任务)*/String taskId=task.getId();taskService.complete(taskId); //根据任务的id处理掉任务&#125; 注意 act_ru_* 表中只会有一条任务实例数据,前一个流程执行完后会把act_ru_*表中数据删除，保留当前执行的数据。只有一条实例数据的好处是查询速度快。 当该流程所有的任务执行完后，act_ru_*表中无该流程的任务数据。所有的数据都保留在了act_hi_*表中 流程定义id、流程部署id、流程实例id、任务id讲解 流程部署id：将资源部署到数据库中时产生 流程定义id：在执行runtimeService的getRuntimeService方法后产生 流程实例id：每个人在执行流程时都会产生一个流程实例id 任务id：zhangsan填写请假是一个任务，有id。lisi审批也是一个任务，也有id]]></content>
      <categories>
        <category>activiti</category>
      </categories>
      <tags>
        <tag>工作流</tag>
        <tag>activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue注意事项]]></title>
    <url>%2F2019%2F11%2F21%2F2019-11-20-vue%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[vue注意事项 $符号的作用 vue中使用$表示一些有用的实例属性与方法 12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)//$data表示data: data中‘：’前的datavm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 使用render渲染组件一般在vue实例中使用render渲染组件 1234render:function(createElements)&#123; //login为import导入的组件 return createElements(login)&#125; 上面导入组件的方式可以简写为 1render: c =&gt; c(login) 注意:如果使用了render，render会把el指定的容器给删除，自己又创建了一个容器]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>$符号</tag>
        <tag>render</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07_loader加载器处理css样式]]></title>
    <url>%2F2019%2F11%2F21%2F2019-11-20-07-loader%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%A4%84%E7%90%86css%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[07_loader加载器处理css样式 loader加载器处理css样式下载loader加载器在组件中可以使用import &#39;./css/index.css&#39;的方式导入样式，但是webpack不能打包 webpack只能打包js的文件，不能打包css文件，所以如果想把css文件打包，需要安装loader加载器 cnpm i style-loader css-loader -D 然后打开webpack.config.js配置文件，在里面新增一个配置节点，叫做module，它是一个对象，在这个对象中，有个rules属性，这是个数组，这个数组里存放了所有第三方文件的匹配和处理规则 1234567module:&#123; //配置所有第三方loader模块的加载器 rules:[ // test:/\.css$/ 这个是处理什么类型的文本 / \.css$ / \.是转义字符. $ 是结尾 这句话意思是处理以.css结尾的文件 // use:['style-loader','css-loader'] 使用什么插件处理 &#123;test:/\.css$/,use:['style-loader','css-loader']&#125; ]&#125;, loader加载器处理less样式除了安装style-loader和css-loader外，还需要安装less-loader 安装less-loader：cnpm i less-loader -D 另外可能还需要安装less：cnpm i less -D 123456789module:&#123; //配置所有第三方loader模块的... rules:[ // test:/\.css$/ 这个是处理什么类型的文本 / \.css$ / \.是转义字符. $ 是结尾 这句话意思是处理以.css结尾的文件 // use:['style-loader','css-loader'] 使用什么插件处理 &#123;test:/\.css$/,use:['style-loader','css-loader']&#125;, //处理less文件 &#123;test:/\.less$/,use:['style-loader','css-loader','less-loader']&#125; ] &#125;, loader加载器处理scss样式除了安装style-loader和css-loader外，还需要安装sacc-loader 安装less-loader：cnpm i sass-loader -D 另外可能还需要安装less：cnpm i node-sacc -D 这个npm可能装不了 12345678910module:&#123; //配置所有第三方loader模块的... rules:[ // test:/\.css$/ 这个是处理什么类型的文本 / \.css$ / \.是转义字符. $ 是结尾 这句话意思是处理以.css结尾的文件 // use:['style-loader','css-loader'] 使用什么插件处理 &#123;test:/\.css$/,use:['style-loader','css-loader']&#125;, &#123;test:/\.less$/,use:['style-loader','css-loader','less-loader']&#125;, //处理scss文件 &#123;test:/\.scss$/,use:['style-loader','css-loader','sass-loader']&#125;, ] &#125;,]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>less</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06_vue]]></title>
    <url>%2F2019%2F11%2F21%2F2019-11-20-06-vue%2F</url>
    <content type="text"><![CDATA[06_vue Vue安装vuenpm i vue -D vue包的查找规则import Vue from &#39;vue&#39;讲解 先找项目根目录中node_modules的文件夹 在node_modules中找vue（包名）文件 在vue文件中，找package.json的配置文件 在package.json的配置文件中，找main属性，这个main指定的就是导入的包 而vue中的main指定的是&quot;main&quot;: &quot;dist/vue.runtime.common.js&quot;,这个包不是很完整，完整的应该是vue.js 如果想导入的是vue.js这个包，有两个方式 一. 在main.js中导入包为import vue from &#39;../node_modules/vue/dist/vue.js&#39; 二. 在webpack.config.js中配置 123456789101112131415161718192021222324const path=require('path')module.exports=&#123; //设置文件入口 entry:path.join(__dirname,'./src/main.js'), //设置文件出口 output:&#123; path:path.join(__dirname,'./dist'), //指定打包好的文件，输出到哪个目录中 filename:'bundle.js' //指定输出文件的名称 &#125;, plugins:[ //所有webpack插件配置节点 ], module:&#123; //配置所有第三方loader模块的... &#125;, resolve:&#123; alias:&#123; //在main.js中导入的vue实际变成了vue/dist/vue.js，这是的import Vue from 'vue'中的vue只是个别名 //"vue$"的意思是以vue结尾 "vue$":"vue/dist/vue.js" &#125; &#125;&#125;s]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05_webpack]]></title>
    <url>%2F2019%2F11%2F21%2F2019-11-20-05-webpack%2F</url>
    <content type="text"><![CDATA[05_webpack webpackwebpack的安装方法 运行npm i webpack -g,全局安装webpack，这样可以在全局使用webpack的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 使用npm在根目录下安装Jquery 先init一下npm init -y 安装Jquery npm i jquery -s 使用webpack打包方式一： webpack ./src/main.js ./dist/bundle.js 方式二： 在webpack.config.js中配置打包的路径 1234567891011const path=require('path')module.exports=&#123; //设置文件入口 entry:path.join(__dirname,'./src/main.js'), //设置文件出口 output:&#123; path:path.join(__dirname,'./dist'), //指定打包好的文件，输出到哪个目录中 filename:'bundle.js' //指定输出文件的名称 &#125;&#125; 目的：使用了html-webpack-plugin后，在index.html中可以不再导入bundle.js 即&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;可以去掉 注意：__dirname前面是两个_ 如果使用第二种方式，在控制台只需要输入webpack就可以实现打包 使用webpack-dev-server工具实现自动打包编译 在本地项目下执行npm i webpack-dev-server -D,安装 但是由于我们是在本地项目中安装的webpack-dev-server，所以无法把它当作脚本文件执行（只有安装到全局-g的才能在powershell中执行） 此时如果想要执行该脚本，在package.json中添加上webpack-dev-server，然后在本地项目下运行npm run dev 如果无法运行的话，需要本地项目下安装webpack webpack打包好的bundle.js文件没有放到硬盘中，而是放到了内存中 在浏览器中输入http://localhost:8080/ webpack-dev-server下的一些参数 –open:执行完npm run dev自动打开浏览器 –port 3000:修改端口为3000 –contenBase src:打开的浏览器为index.html页面内容 –hot：有两个作用 修改样式是不会再创建一个bundle.js，而是保留原有bundle.js，然后做些修改 修改样式时浏览器页面不刷新 参数加的位置 1234"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack-dev-server --open --prot 3000 --contenBase src --hot" &#125;, 然后重新执行npm run dev html-webpack-plugin的作用 安装插件，在项目下执行npm i html-webpack-plugin -D 配置 第一步：在webpack.config.js中导入插件 const htmlWebpackPlugin=require(&#39;html-webpack-plugin&#39;) 第二步：在webpack.config.js中配置插件 123456new htmlWebpackPlugin(&#123; //指定模板路径，将来会根据指定的页面路径，生成内存中的页面 template:path.join(__dirname,'./src/index.html'), //指定在内存中生成的页面的名称 filename:'index.html'&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>webpack-dev-server</tag>
        <tag>html-webpack-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04_vue组件和路由]]></title>
    <url>%2F2019%2F11%2F21%2F2019-11-20-04-vue%E7%BB%84%E4%BB%B6%E5%92%8C%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[04_vue组件和路由 Vue的组件和路由全局组件和局部组件123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;global&gt;&lt;/global&gt; &lt;local&gt;&lt;/local&gt; &lt;/div&gt; &lt;script&gt; //这个是全局组件 Vue.component('global',&#123; template:'&lt;h1&gt;自定义全局组件&lt;/h1&gt;' &#125;) var vm = new Vue(&#123; el:'#app', //local这个组件是定义在app里的，所以是局部的 components:&#123; 'local':&#123; template:'&lt;h1&gt;自定义局部组件&lt;/h1&gt;' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; props属性用于传递组件间的数据 1234567891011121314151617181920&lt;body&gt; &lt;div id="app"&gt; &lt;comp v-bind:msg="site"&gt;&lt;/comp&gt; &lt;/div&gt; &lt;script&gt; Vue.component('comp',&#123; //把父组件的数据传递到子组件里 props:['msg'], //使用这个数据 template:'&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;' &#125;) new Vue(&#123; el:'#app', data:&#123; site:'helloworld' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; prop验证123456789101112131415161718192021222324252627282930313233Vue.component('my-component', &#123; props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 组件中的data12345678910111213141516171819202122&lt;body&gt; &lt;div id="app"&gt; &lt;mycom&gt;&lt;/mycom&gt; &lt;/div&gt; &lt;script&gt; Vue.component('mycom',&#123; template:'&lt;h1&gt;这是个全局组件---&#123;&#123;msg&#125;&#125;&lt;/h1&gt;', //1.在组件中也可以定义data，但是data不能是对象类型，只能是函数类型，而且必须有返回值，且返回值为对象 //2.组件中的data数据使用方式和实例中data的使用方式一样 data:function()&#123; return &#123; msg:'这是组件data中的数据' &#125; &#125; &#125;) new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123;&#125; &#125;) &lt;/script&gt;&lt;/body&gt; emit将子组件数据传递给父组件数据123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;div id="app"&gt; &lt;div id="conter-event-example"&gt; &lt;!-- 6.值增加 --&gt; &lt;p&gt;&#123;&#123;total&#125;&#125;&lt;/p&gt; &lt;!-- 4.到父组件后执行函数countertotal --&gt; &lt;button-conter v-on:counterzj="countertotal"&gt;&lt;/button-conter&gt; &lt;button-conter v-on:counterzj="countertotal"&gt;&lt;/button-conter&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.component('button-conter',&#123; //1.点击button按钮，触发函数clickta template:'&lt;button v-on:click="clickta"&gt;&#123;&#123;counter&#125;&#125;&lt;/button&gt;', data:function()&#123; return &#123; counter:0 &#125; &#125;, methods:&#123; //2.触发的函数clickta，实现自增 clickta:function()&#123; this.counter+=1, //3.emit用于触发事件，用于把子组件数据传递给父组件，这一步直接执行父组件的counterzj this.$emit('counterzj') &#125; &#125; &#125;) new Vue(&#123; el:'#conter-event-example', data:&#123; total:0 &#125;, methods:&#123; //5.函数countertotal实现自增 countertotal:function()&#123; this.total+=1 &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 路由的基本使用 访问路由后面加/login,可以访问跳转到登录组件 file:///D:/Hui/Persion/Application/vue/code/v-route.html#/login 访问路由后面加/register，可以访问跳转到注册组件 file:///D:/Hui/Persion/Application/vue/code/v-route.html#/register 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 路由规则匹配的组件，是放到router-view里的，可以理解为一个DOM或者容器，用于存放路由匹配到的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; //解释：什么是组件的模板对象，什么是组件的引用名称 //组件的模板对象,这里的login就是模板对象 var login=&#123; template:'&lt;h1&gt;登录组件&lt;/h1&gt;' &#125; var register=&#123; template:'&lt;h1&gt;注册组件&lt;/h1&gt;' &#125; //组件的引用名称，这里的login就是引用名称 Vue.component('login',&#123; template:'&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;) //在导入vue-router包之后，在windows全局对象中，就有了一个路由的构造函数，叫做VueRouter var routerobj=new VueRouter(&#123; // route 这个配置对象中的route表示[路由匹配规则]的意思 routes:[ //routes表示多个路由匹配规则 //每个路由匹配规则都有一个对象，每个对象都两个属性 //path:表示监听，路由的链接地址 //component：表示如果路由是前面匹配的path，就展示component属性对应的组件 //注意：component属性值，必须是一个组件的模板对象，不能是组件的引用名称 &#123;path:'/login',component:login&#125;, &#123;path:'/register',component:register&#125; ] &#125;) var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123;&#125;, //将路由规则和实例对象关联，注册到vm实例上，用于监听url地址的变化，然后展示对应组件 router:routerobj &#125;) &lt;/script&gt;&lt;/body&gt; 组件的访问方式123456789101112&lt;div id="app"&gt; &lt;!-- 这是一般的写法，前面必须加# --&gt; &lt;!-- &lt;a href="#/login"&gt;登录&lt;/a&gt; &lt;a href="#/register"&gt;注册&lt;/a&gt; --&gt; &lt;!-- 这是官方的写法,推荐使用.router-link渲染出来是a标签，如果想要渲染为span标签，可以加上tag="span" --&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register" tag="span"&gt;注册&lt;/router-link&gt; &lt;!-- 路由规则匹配的组件，是放到router-view里的，可以理解为一个DOM或者容器，用于存放路由匹配到的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 修改初始页面加载的组件两种方法： 123//加这一步是为了加载初始页面时直接跳转到login组件&#123;path:'/',component:login&#125;,//但是访问路径是根路径，组件是登录组件，这样不太合理，不推荐 12//这一步可以直接在初始加载时进入的路径和组件都是登录组件&#123;path:'/',redirect:'login'&#125;, 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 这是一般的写法，前面必须加# --&gt; &lt;!-- &lt;a href="#/login"&gt;登录&lt;/a&gt; &lt;a href="#/register"&gt;注册&lt;/a&gt; --&gt; &lt;!-- 这是官方的写法,推荐使用 --&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register" tag="span"&gt;注册&lt;/router-link&gt; &lt;!-- 路由规则匹配的组件，是放到router-view里的，可以理解为一个DOM或者容器，用于存放路由匹配到的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; //解释：什么是组件的模板对象，什么是组件的引用名称 //组件的模板对象,这里的login就是模板对象 var login=&#123; template:'&lt;h1&gt;登录组件&lt;/h1&gt;' &#125; var register=&#123; template:'&lt;h1&gt;注册组件&lt;/h1&gt;' &#125; //组件的引用名称，这里的login就是引用名称 Vue.component('login',&#123; template:'&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;) //在导入vue-router包之后，在windows全局对象中，就有了一个路由的构造函数，叫做VueRouter var routerobj=new VueRouter(&#123; // route 这个配置对象中的route表示[路由匹配规则]的意思 routes:[ //routes表示多个路由匹配规则 //每个路由匹配规则都有一个对象，每个对象都两个属性 //path:表示监听，路由的链接地址 //component：表示如果路由是前面匹配的path，就展示component属性对应的组件 //注意：component属性值，必须是一个组件的模板对象，不能是组件的引用名称 //加这一步是为了加载初始页面时直接跳转到login组件 // &#123;path:'/',component:login&#125;, //这一步可以直接在初始加载时进入的路径和组件都是登录组件 &#123;path:'/',redirect:'login'&#125;, &#123;path:'/login',component:login&#125;, &#123;path:'/register',component:register&#125; ] &#125;) var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123;&#125;, //将路由规则和实例对象关联，注册到vm实例上，用于监听url地址的变化，然后展示对应组件 router:routerobj &#125;) &lt;/script&gt;&lt;/body&gt; 路由样式的设置路由默认样式class：router-link-active 直接在样式中设置： 12345678&lt;style&gt; .router-link-active&#123; color:red; font-weight: 800; font-size: 200%; &#125;&lt;/style&gt; 如果想要修改默认的router-link-active，可以在路由构造函数中使用自己定义的样式 linkActiveClass:&#39;mystyle&#39; 路由规则中定义参数方式一：query123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 可以在to属性的地址后面加请求参数,要获取该值，可以使用this.$route.query.id和this.$route.query.name。this可以省去 --&gt; &lt;router-link to="/login?id=2&amp;name=zhangsan"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login=&#123; template:'&lt;h1&gt;登录 --- &#123;&#123;$route.query.id&#125;&#125; --- &#123;&#123;this.$route.query.name&#125;&#125;&lt;/h1&gt;' &#125; var register=&#123; template:'&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router=new VueRouter(&#123; routes:[ &#123;path:'/login',component:login&#125;, &#123;path:'/register',component:register&#125;, ] &#125;) new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123;&#125;, //本是写成router:router，但由于是一样的，所以可以直接写router router &#125;) &lt;/script&gt;&lt;/body&gt; 路由规则中定义参数方式一：params12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 可以在to属性的地址后面加请求参数,要获取该值，可以使用this.$route.params.id和this.$route.params.name --&gt; &lt;router-link to="/login/3/lisi"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login=&#123; template:'&lt;h1&gt;登录 --- &#123;&#123;$route.params.id&#125;&#125; --- &#123;&#123;$route.params.name&#125;&#125;&lt;/h1&gt;' &#125; var register=&#123; template:'&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router=new VueRouter(&#123; routes:[ //:id表示占位符 &#123;path:'/login/:id/:name',component:login&#125;, &#123;path:'/register',component:register&#125;, ] &#125;) new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123;&#125;, //本是写成router:router，但由于是一样的，所以可以直接写router router &#125;) &lt;/script&gt;&lt;/body&gt; 使用children实现路由的嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 跳转 --&gt; &lt;router-link to="/index"&gt;首页&lt;/router-link&gt; &lt;!-- 显示路由 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id="temp"&gt; &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;!-- router-link一定要被div或者什么属性包裹，否则无法显示 --&gt; &lt;router-link to="/index/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/index/register"&gt;注册&lt;/router-link&gt; &lt;!-- 子组件的显示容器 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var index=&#123; template:'#temp' &#125; var login=&#123; template:'&lt;h3&gt;登录&lt;/h3&gt;' &#125; var register=&#123; template:'&lt;h3&gt;注册&lt;/h3&gt;' &#125; //定义路由 var router=new VueRouter(&#123; routes:[ &#123; path:'/index', component:index, children:[ //子组件中不能加/ &#123;path:'login',component:login&#125;, &#123;path:'register',component:register&#125; ] &#125; ] &#125;) new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123;&#125;, router &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03_vue常用属性]]></title>
    <url>%2F2019%2F11%2F21%2F2019-11-20-03-vue%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[03_vue常用属性 vue常用属性过滤器该概念的应用还不熟悉 1234567891011121314151617181920&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt;&#123;&#123; message | filter&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; message:'helloworld' &#125;, filters:&#123; filter:function(value)&#123; if(!value) return '' value=value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 计算属性123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt;&#123;&#123; site &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app', data:&#123; name:'google', url:'http://www.google.com', &#125;, //计算属性使用get时可以这样写 // computed:&#123; // site:function()&#123; // return this.message + '==' + this.addredd // &#125; // &#125; computed:&#123; site:&#123; get:function()&#123; return this.name + ':' + this.url &#125;, set:function(newvalue)&#123; //split(' ')是按照空格分割 var names=newvalue.split(' ') this.names=names this.name=names[0] this.url = names[names.length - 1] &#125; &#125; &#125; &#125;) //在运行 vm.site = '菜鸟教程 http://www.runoob.com'; 时，setter 会被调用， vm.name 和 vm.url 也会被对应更新 vm.site='菜鸟教程 http://www.runoob.com'; document.write('names:'+vm.names); document.write('&lt;br&gt;'); document.write('name:'+vm.name); document.write('&lt;br&gt;'); document.write('url: ' + vm.url); &lt;/script&gt;&lt;/body&gt; 计算属性和不带返回值方法以及带返回值方法的使用12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id="app"&gt; &lt;button @click="fun"&gt;点击&lt;/button&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt; &lt;h1&gt;&#123;&#123;func()&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;funcom&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; msg:1 &#125;, methods:&#123; //带有返回值的 func:function()&#123; return '你好' &#125;, //不带返回值的 fun:function()&#123; this.msg=this.msg+1 &#125; &#125;, computed:&#123; funcom:function()&#123; return '你好啊' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 监听属性123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id="app"&gt; 米：&lt;input type="text" v-model="meters"&gt; 千米：&lt;input type="text" v-model="kilometers"&gt; &lt;/div&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app', data:&#123; meters : 0, kilometers : 0 &#125;, watch:&#123; meters:function(val)&#123; this.kilometers=val/1000; this.meters=kilometers; &#125;, kilometers:function(val)&#123; this.meters=val*1000; this.kilometers=meters &#125; &#125; &#125;); //$watch是一个实例方法 //function(newValue,oldValue)留意一下newValue和oldValue的位置，不能反 vm.$watch('meters',function(newValue,oldValue)&#123; alert('米修改前：'+oldValue+' '+'米修改后:'+newValue) &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>过滤器</tag>
        <tag>计算属性</tag>
        <tag>监听</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02_vue的class属性绑定]]></title>
    <url>%2F2019%2F11%2F21%2F2019-11-20-02-vue%E7%9A%84class%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[02_vue的class属性绑定 vue的calss属性绑定vue一共有四种属性绑定的方式 使用数组 使用三元表达式 使用对象 将对象写到data里 123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; .color&#123; color: red; &#125; .font&#123; font-size: 300% &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- :class实际上是v-bind:class --&gt; &lt;!-- 1.数组的形式 数组里要是字符串的形式，所以加'' --&gt; &lt;h3&gt;1.使用数组&lt;/h3&gt; &lt;pre :class="['color','font']"&gt;&#123;&#123;massage&#125;&#125;&lt;/pre&gt; &lt;!-- 用于改变flag的值 --&gt; &lt;label for="haha"&gt;点击查看样式&lt;/label&gt; &lt;input type="checkbox" v-model="flag" id="haha"&gt; &lt;!-- 2.数组中写三元表达式的形式 --&gt; &lt;h3&gt;2.三元表达式&lt;/h3&gt; &lt;pre :class="['color',flag?'font':'']"&gt;&#123;&#123;massage&#125;&#125;&lt;/pre&gt; &lt;!-- 3.使用对象,使用对象时，''可加可不加 --&gt; &lt;h3&gt;3.使用对象&lt;/h3&gt; &lt;pre :class="&#123;color:true,font:flag&#125;"&gt;&#123;&#123;massage&#125;&#125;&lt;/pre&gt; &lt;!-- 4.对象写到data里 --&gt; &lt;h3&gt;4.对象写到data里&lt;/h3&gt; &lt;pre :class="classStyle"&gt;&#123;&#123;massage&#125;&#125;&lt;/pre&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; massage:'精忠报国', flag:false, //&#123;color:true,font:true&#125;是对象，不能加'' classStyle:&#123;color:true,font:true&#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01_vue的入门]]></title>
    <url>%2F2019%2F11%2F21%2F2019-11-20-01-vue%E7%9A%84%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[01_vue的入门 MVC和MVVM关系图 MVVM详解123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- MVVM中的M --&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; massage &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; //MVVM中的MV new Vue(&#123; el:'#app', //标记属性，指定是使用的哪个M //MVVM中的V data:&#123; //数据交互 massage:'欢迎来到Vue' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue常用语法 v-html : 获取html格式的数据 1234567891011121314&lt;body&gt; &lt;div id="app"&gt; &lt;div v-html="massage"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; massage:'&lt;h1&gt;这是个标题&lt;/h1&gt;' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-bind: 用于绑定属性 12345678910111213141516171819202122&lt;style&gt; .testfont&#123; font-size: 300% &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;label for="haha"&gt;修改大小&lt;/label&gt; &lt;input type="checkbox" v-model="use" id="haha"&gt; &lt;div v-bind:class="&#123;'testfont':use&#125;"&gt; wanghui &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; use:false &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 字符串先拆分成数组，再反转，再合并 12345678910111213&lt;body&gt; &lt;div id="app"&gt; &#123;&#123; massage.split('').reverse().join('')&#125;&#125; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; massage:'helloworld' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-if:用于做判断 123456789101112131415&lt;body&gt; &lt;div id="app"&gt; &lt;label for="haha"&gt;点击显示和消失&lt;/label&gt; &lt;input type="checkbox" v-model="flag" id="haha"&gt; &lt;h1 v-if=flag&gt;精忠报国&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; flag:false &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 参数 参数要跟着指令后面 123456789101112131415&lt;body&gt; &lt;div id="app"&gt; &lt;a v-bind:href="url"&gt;百度&lt;/a&gt; &lt;br&gt; &lt;a href="https://www.baidu.com"&gt;百度链接&lt;/a&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; url:'https://www.baidu.com' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-model 用于数据的双向绑定 123456789101112131415&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-bind和v-model的区别v-bind是数据的单向绑定，被v-bind绑定的数据，如果在M数据层修改了数据，那在V视图层也会被修改。v-bind可以省略，只写： 123456789101112131415161718&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt;&#123;&#123; massage &#125;&#125;&lt;/div&gt; &lt;!-- &lt;input type="text" value="massage"&gt; 这样写没有吧massage绑定到value上--&gt; &lt;!-- 单向绑定的解释：massage是显示在V视图层上的，此时修改text里的值，就是修改V视图上的值，因为数据没有同步到M数据层 ，所以&lt;div&gt;&#123;&#123; massage &#125;&#125;&lt;/div&gt;中的massage不会改变 --&gt; &lt;input type="text" v-bind:value="massage"&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; massage:'hellword!!!' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-model是数据的双向绑定，被v-model绑定的数据，在M数据层修改，在V视图层会被修改。在V视图层修改的数据，在M数据层也会被修改 1234567891011121314151617181920212223&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt;&#123;&#123; massage &#125;&#125;&lt;/div&gt; &lt;!-- &lt;input type="text" value="massage"&gt; 这样写没有吧massage绑定到value上--&gt; &lt;!-- 双向绑定的解释：massage是显示在V视图层上的，此时修改text里的值，就是修改V视图上的值，因为是双向绑定，数据同步到M数据层 ，而&lt;div&gt;&#123;&#123; massage &#125;&#125;&lt;/div&gt;中的massage就是从M层获取的，所以也会跟着改变 写了v-model后，就不用写value了 v-model使用场合： 只能用于表单元素中，例如： input&#123;radio,text,address,email...&#125; select checkbox textarea --&gt; &lt;input type="text" v-model="massage"&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; massage:'hellword!!!' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-if和v-show的区别123456789101112131415161718192021222324&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" @click="cli" value="按钮"&gt; &lt;!-- v-if是每次都是DOM的删除或者新增 相当于&lt;pre v-if="seen"&gt;&lt;h1&gt;HelloWorld&lt;/h1&gt;&lt;/pre&gt;被完全删除或者新增--&gt; &lt;!-- v-if 有较高的切换性能消耗 使用场合：如果元素可能永远不会被显示出来被客户看到，推荐v-if --&gt; &lt;pre v-if="seen"&gt;&lt;h1&gt;HelloWorld&lt;/h1&gt;&lt;/pre&gt; &lt;!-- v-show不会删除DOM，只是把属性改成display=none --&gt; &lt;!-- v-show有较高的初始渲染消耗 使用场合：元素频繁被切换，推荐v-show，而不用v-if --&gt; &lt;pre v-show="seen"&gt;&lt;h1&gt;HelloWorld&lt;/h1&gt;&lt;/pre&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; seen:false &#125;, methods:&#123; cli()&#123; this.seen=!this.seen &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-for1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 普通的循环 --&gt; &lt;div v-for="site in sites"&gt; &#123;&#123; site.name &#125;&#125; &lt;/div&gt; &lt;!-- 循环出来key和value 数组--&gt; &lt;li v-for="(key,value) in sites"&gt; &#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;!-- 对象 --&gt; &lt;li v-for="(key,value) in object"&gt; &#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;!-- index为索引 --&gt; &lt;li v-for="(key,value,index) in object"&gt; &#123;&#123;index&#125;&#125;:&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;!-- 循环数字 --&gt; &lt;div v-for="n in 10"&gt; &#123;&#123;n&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el:'#app', data:&#123; sites:[ &#123;'name':"zhangsan"&#125;, &#123;'name':'lisi'&#125;, &#123;'name':'wangwu'&#125; ], object:&#123; name:'zhangsan', age:18, address:'中国' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>vue base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue-cli搭建项目]]></title>
    <url>%2F2019%2F09%2F04%2F2019-05-08-%E4%BD%BF%E7%94%A8vue-cli%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[使用vue-cli搭建项目 使用vue-cli搭建项目安装node.js首先需要安装node环境 1、这是node.js最新固定版本下载地址：http://nodejs.cn 2、这是多版本的node.js的下载地址：https://blog.csdn.net/s8460049/article/details/52396399 安装完成后，可以在该文件夹下打开cmd命令工具输入node -v和npm -v，如果能显示出版本号，就说明安装成功。 安装vue-cli1、先安装cnpm，因为npm执行速度比较慢 1npm install -g cnpm --registry=https://registry.npm.taobao.org 2、安装vue-cli和webpack 1cnpm install -g vue-cli 最新的vue项目模板中，都有webpack插件，所以这里可以不安装 3、执行vue -V查看是否安装成功，可能会出现以下错误 1234567vue : 无法加载文件 C:\Users\wanghui\AppData\Roaming\npm\vue.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。所在位置 行:1 字符: 1+ vue -V+ ~~~ + CategoryInfo : SecurityError: (:) []，PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess 解决方案： 1. 以管理员身份运行PowerShell 2. 执行：get-ExecutionPolicy，回复Restricted，表示状态是禁止的 3.执行：set-ExecutionPolicy RemoteSigned 4.选择Y 注意：一定要以管理员的身份运行PowerShell，不是cmd窗口 生成项目首先需要在命令行中进入到项目目录，然后输入： 1vue init webpack Vue-Project 其中webpack是模板名称，可以到vue.js的GitHub上查看很多的模板https://github.com/vuejs-templates Vue-Project是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹 由于webpack是托管在github上的，因此直接执行vue init webpack Vue-Project会连接不上主机，可以在https://gitlab.com/wanghui20192/webpack； 将webpack下载到本地，然后执行： 12#这里会有一些配置，默认回车即可vue init C:\wanghui\persion\docs\01_javaEE\vue\code\webpack Vue-Project 其中的C:\wanghui\persion\docs\01_javaEE\vue\code\webpack为我本机下载下来的webpack位置。 进入项目，安装并运行123$ cd vue-project$ cnpm install$ cnpm run dev 访问：http://localhost:8080； 页面正常访问，即成功了 项目目录介绍 目录/文件 说明 build 项目构建(webpack)相关代码 config 配置目录，包括端口号等。我们初学可以使用默认的。 node_modules npm 加载的项目依赖模块 src 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：1.assets：存图片，如logo 2.components：存组件，可以不用 3.App.vue：项目的入口，我们也可以直接将组件写这里，而不使用 components 目录 4.main.js：项目的核心文件 static 静态资源目录，如图片、字体等。 test 初始测试目录，可删除 .xxxx文件 这些是一些配置文件，包括语法配置，git配置等。 index.html 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。 package.json 项目配置文件。 README.md 项目的说明文档，markdown 格式]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins部署项目-项目运行02]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-25-Jenkins%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE-%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C02%2F</url>
    <content type="text"><![CDATA[持续集成，持续交付第二章-项目运行02 jenkins使用触发远程构建连接gitlab在jenkins中新建项目–&gt;选择pipeline 配置–&gt;Discard old builds(填写保留10)–&gt;选触发远程构建 身份令牌:123456(随便设置的) 在全局安全设置里需要设置: 匿名用户具有可读权限打钩 防止跨站点请求伪造去掉钩 进入gitlab,找到需要构建的项目–&gt;设置–&gt;集成(导入所有仓库) URL:填写图1中的链接(填写ip地址,token为令牌密码) 如果test不成功,则使用root用户登录gitlab 如图设置 设置一下网络 配置pipeline脚本 在jenkins里选择项目–&gt;配置–&gt;流水线 然后在pipeline的脚本里写 12345678910111213141516171819202122232425262728293031323334353637383940pipeline&#123; agent any tools&#123; maven 'Maven 3' &#125; environment&#123; REPOSITORY="ssh://git@192.168.10.140:2222/my-shop/myshop-dependencies.git" &#125; stages&#123; stage('获取代码') &#123; steps &#123; echo "start fetch code from git:$&#123;REPOSITORY&#125;" deleteDir() git "$&#123;REPOSITORY&#125;" &#125; &#125; stage('代码静态检查') &#123; steps &#123; echo "start code check" &#125; &#125; stage('编译+单元测试') &#123; steps &#123; echo "start compile" sh "mvn -B -DskipTests clean package" &#125; &#125; stage('构建镜像') &#123; steps &#123; echo "start build image" &#125; &#125; stage('发布系统') &#123; steps &#123; echo "start deploy" &#125; &#125; &#125; &#125; 注意以下两点: 1234567agent any tools&#123; maven 'Maven 3' &#125; environment&#123; REPOSITORY="ssh://git@192.168.10.140:2222/my-shop/myshop-dependencies.git" &#125; maven的名称来源于jenkins中maven的配置中的name Manage Jenkins–&gt;全局工具配置 REPOSITORY=&quot;ssh://git@192.168.10.140:2222/my-shop/来源于gitlab中的项目 设置docker的远程访问凡是装有docker,并需要远程访问的虚拟机都要设置,我这里以设置jenkins虚拟机为例子 vi /etc/systemd/system/multi-user.target.wants/docker.service 将# for containers run by docker下改为: ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock 关闭防火墙 ufw disable 重启docker 12$ systemctl daemon-reload$ sudo service docker restart 在Jenkins中安装docker插件 Manage Jenkins–&gt;系统设置–&gt;云–&gt;新增一个docker云 起个name,后面用的到.name:docker-jenkins Docker Host URI:tcp://192.168.21.143:2375:ip为开启的远程docekr的机器ip 测试–&gt;出现docker版本号就说明连接成功了 jenkins连接harborManage Jenkins–&gt;系统设置–&gt;Pipeline Model Definition Docker Label:harbor Docker registry URL:http://192.168.21.xx(这个是harbor虚拟机的ip地址) 添加Jenkins]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>mysql</tag>
        <tag>redis</tag>
        <tag>nexus</tag>
        <tag>jekins</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用教程]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-25-Git%E5%B8%B8%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[git的流程，commit规则，图标意义，连接多个ssh方法 Git 常用教程$ git config --global user.name &quot;Firstname Lastname&quot; $ git config --global user.email &quot;your_email@example.com&quot; 配置在下面文件:~/.gitconfig 输出内容显示:git config --global color.ui auto 设置SSH Key ssh-keygen -t rsa -C &quot;your_email@example.com&quot;cat ~/.ssh/id_rsa.pub添加到远程Git服务网站ssh -T git@github.com 第一次: 12345678910111213141516171819git clone git@github.com:hirocastest/Hello-World.gittouch hello_world.php &amp;&amp; vim hello_world.php&lt;?php echo "Hello World!";?&gt;cd Hello-Worldgit statusgit add hello_world.phpgit commit -m "Add hello world script by php"git loggit push 标准流程 开发或修正:develop-&gt;feature branches 合并:feature branches-&gt;develop 发布:release branches 合并:release branches-&gt;master 然后打Tag发布 发现BUG:master-&gt;hotflixes 工具git-flow Mac安装:brew install git-flow 仓库初始化Github-&gt;Git仓库-&gt;Add README.md-&gt;blog git clone git flow init -d git branch -a git push -u origin develop git branch -a 模拟 Git Flowgit pull 创建feature分支add-usergit flow feature start add-user git branch git push origin feature/add-user PR的要点: 没有测试or测试未通过 违反编码规则 代码品质过低(命名不明确,方法冗长等) 还有重构的余地 有重复的部分 切换分支,保证develop最新develop是默认分支 git checkout develop git pull 发布git checkout develop git pull git flow release start &#39;1.0.0&#39; git flow release finish &#39;1.0.0&#39; git tag 更新到远程仓库 git push origin develop git checkout master git push origin master git push --tags 在hotfix分支工作 git fetch origin git flow hotfix start &#39;1.0.1&#39; &#39;1.0.0&#39; git push origin hotfix/1.0.1 查看Tag git fetch origin git tag 版本号的分配规则 x.y.z格式进行版本管理 x在重大功能变更或新版本不向下兼容时加1,此时y与z的数字归0 y在添加新功能或者删除已有功能时加1, 此时z的数字归0 z只在进行内部修改后加1 具体例子:1.0.0 最初发布的版本1.0.1 修正了轻微BUG1.0.2 修复漏洞1.1.0 添加新功能2.0.0 更新整体UI并添加新功能 Commit Message Guidelines https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commits https://www.conventionalcommits.org/en/v1.0.0-beta.4/ git commit cp 规范 https://github.com/Dolov/git-commit-cp http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html https://udacity.github.io/git-styleguide/ https://juejin.im/post/5afc5242f265da0b7f44bee4 https://www.jianshu.com/p/b9d5a0711528 Commit message(提交说明) -m 参数 指定commit message 的 多行 git commit 清晰明了 说明目的 格式: 三个部分:Header,Body和Footer &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; Header 是必须Body和Footer 可用省略 任何一行都不能超过72个字符(或100个字符) 避免换行 Header: type(必需)、scope(可选)、subject(必需) type: 说明commit的类别,只允许使用下面7个标示 feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要 scope scope 用于说明commit影响的范围, 比如数据层、控制层、视图层等,视项目不同而不同 subject subject是commit目的的简短描述, 不超过50个字符 以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号（.） Body Body部分是对本次commit的详细描述, 可以分成多行. 示例: More detailed explanatory text, if necessary. Wrap it toabout 72 characters or so. Further paragraphs come after blank lines. Bullet points are okay, too Use a hanging indent 注意点: 使用第一人称现在时，比如使用change而不是changed或changes。 应该说明代码变动的动机，以及与以前行为的对比。 Footer Footer 部分只用于两种情况 不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: 123scope: &#123; myAttr: 'attribute',&#125; After: 123scope: &#123; myAttr: '@',&#125; The removed inject wasn’t generaly useful for directives so there should be no code using it. 关闭Issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue. Closes #234 也可以一次关闭多个 issue Closes #123, #245, #992 Revert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 revert: feat(pencil): add ‘graphiteWidth’ option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 编写工具 Commitizen:https://github.com/commitizen/cz-cli http://commitizen.github.io/cz-cli/ npm install -g commitizen commitizen init cz-conventional-changelog –save –save-exact git add . git cz 检查Commit message 是否符合格式 validate-commit-msg:https://github.com/kentcdodds/validate-commit-msg https://github.com/kentcdodds/validate-commit-msg/blob/master/index.js 重命名为下面名字validate-commit-msg.js 加入Git的hook package.json-&gt;ghooks:http://npm.im/ghooks 12345"config": &#123; "ghooks": &#123; "commit-msg": "./validate-commit-msg.js" &#125;&#125; example $ git add -A$ git commit -m &quot;edit markdown&quot;INVALID COMMIT MSG: does not match “(): “ ! was: edit markdown Commit Message -&gt; Change log 三部分组成: New featuresBug fixesBreaking changes. 工具: conventional-changelog 123$ npm install -g conventional-changelog$ cd my-project$ conventional-changelog -p angular -i CHANGELOG.md -w CHANGELOG.md 生成所有发布的 Change log $ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 package.json 12345&#123; "scripts": &#123; "changelog": "conventional-changelog -p angular -i CHANGELOG.md -w -r 0" &#125;&#125; $ npm run changelog 工具链: commitizen/cz-cli commitizen/cz-conventional-changelog conventional-changelog/standard-version 持续集成: marionebl/commitlint Git 的表情使用 https://mkblog.cn/872/ https://gitmoji.carloscuesta.me/ 🎨 - 改进结构和代码格式⚡️ - 优化性能🔥 - 移除代码或文件🐛 - 修复 bug✨ - 引入新功能🍎 - 修复 MacOS 下的问题📝 - 写文档🚀 - 部署新功能 ✅ - 添加测试用例🔖 - 发版/版本标签🔒 - 修复安全问题🐧 - 修复 Linux 下的问题🚨 - 移除 linter 的警告🚧 - 工作在进行中💚 - 修复 CI 构建问题⬇️ - 降级依赖库 🏁 - 修复 Windows 下的问题⬆️ - 升级依赖库👷 - 添加 CI 构建系统🔧 - 改变配置文件🔨 - 大重构🎉 - 初次提交💄 - 升级 UI 和样式文件 Git README 编写 https://github.com/kefranabg/readme-md-generator 增加 .gitignore https://github.com/github/gitignore.git 增加 license https://blog.csdn.net/testcs_dn/article/details/38496107 Git 配置 多个 SSH Key ssh-keygen -t rsa -C &#39;xxxxx@company.com&#39; -f ~/.ssh/gitee_id_rsa ssh-keygen -t rsa -C &#39;xxxxx@qq.com&#39; -f ~/.ssh/github_id_rsa ssh-keygen -t rsa -C &#39;xxxxx@qq.com&#39; -f ~/.ssh/gitlab_id_rsa ssh-keygen -t rsa -C &#39;xxxxx@qq.com&#39; -f ~/.ssh/gitlab_own_id_rsa ssh-keygen -t rsa -C &#39;xxxxx@qq.com&#39; -f ~/.ssh/bitbucket_id_rsa touch ~/.ssh/config 12345678910111213141516171819202122232425# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa# gitlabHost gitlab.comHostName gitlab.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitlab_id_rsa# gitlab ownHost gitlab.crm.comHostName gitlab.crm.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitlab_own_id_rsa# bitbucketHost bitbucket.orgHostName bitbucket.orgPreferredAuthentications publickeyIdentityFile ~/.ssh/bitbucket_id_rsa $ ssh -T git@gitee.com$ ssh -T git@github.com$ ssh -T git@gitlab.com$ ssh -T git@gitlab.crm.com$ ssh -T git@bitbucket.org 1个项目push多个远程仓库 git remote add github https://github.com/yhyangjiabin/test.gitgit remote add gitee https://gitee.com/yhyangjiabin/test.gitgit remote add gitlab https://gitlab.com/yhyangjiabin/test.gitgit remote add gitlab_own https://gitlab.crm.com/yhyangjiabin/test.gitgit remote add bitbucket https://bitbucket.org/yhyangjiabin/test.git git push -u github mastergit push -u gitee mastergit push -u gitlab mastergit push -u github_own mastergit push -u bitbucket master git remote git remote -v 移除git remote rm gitee 项目命名 Repository name https://sinkcup.github.io/programming-project-name-best-practice https://en.wikipedia.org/wiki/Clean_URL 凡是会出现在链接中的名字（用户名、组织名、项目名、branch名、tag名），都一定不要使用下划线，而使用中横线。原因：下划线会与浏览器默认样式重合，导致看起来像空格。 优先全小写，而不要使用驼峰。原因：便于用户手动输入。 项目起名和域名无关。原因：买到更好的域名时，域名就换了。 语义化后缀，看名字就知道是什么项目。 举例: 电子书项目 产品线 ebook接口 ebook-apiJS的网站 ebook-web-app微信小程序 ebook-wechat-mini-program安卓APP ebook-android-app苹果APP ebook-ios-app管理员后台网站（假如是PHP/Python等前后端混合的） ebook-admin-web管理员后台JS网站（假如是JS前后端分离的） ebook-admin-web-app管理员后台接口（假如是JS前后端分离的） ebook-admin-api GUI 客户端 GitHub Desktop:https://desktop.github.com/SourceTree:https://www.sourcetreeapp.com/]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>流程</tag>
        <tag>commit</tag>
        <tag>图标</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitFlow工作流]]></title>
    <url>%2F2019%2F06%2F25%2F2019-06-24-GitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[GitFlow的分支介绍 GitFlow分支介绍历史分支master分支：是最终稳定能成型的代码分支。更新次数一月或者两月一次 develop分支：开发人员用的主分支，存放经过测试后没有问题的代码分支 功能分支feature分支：是开发人员写功能的分支，开发人员在develop分支下新建一个feature分支，例如feature-login，然后开始编写功能，最后功能测试没有问题时，将其合并到develop分支中。 发布分支release分支：一旦develop分支上有了一次发布的足够功能，从develop分支上fork一个release分支(基于develop分支创建)。 此后： 该分支不能再添加新的功能，只能做Bug修复，文档生成和其它面向发布任务。 发布任务完成后，合并到master分支上，并打上tag 还有合并回develop分支一份 维护分支hotfix分支：修复Bug的分支，其是唯一一个可以从master分支fork的分支(基于master分支创建)。修复完成，修改应该马上合并回master分支和develop分支（当前的发布分支），master分支应该用新的版本号打好Tag。 示例下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。 创建开发分支：第一步为master分支配套一个develop分支。简单来做可以本地创建一个空的develop分支，push到服务器上： git branch developgit push -u origin develop 以后这个分支将会包含了项目的全部历史，而master分支将只包含了部分历史。其它开发者这时应该克隆中央仓库，建好develop分支的跟踪分支： git clone ssh://user@host/path/to/repo.gitgit checkout -b develop origin/develop 现在每个开发都有了这些历史分支的本地拷贝。 小红和小明开始开发新功能这个示例中，小红和小明开始各自的功能开发。他们需要为各自的功能创建相应的分支。新分支不是基于master分支，而是应该基于develop分支： git checkout -b feature-login develop 他们用老套路添加提交到各自功能分支上：编辑、暂存、提交：git statusgit addgit commit 小红完成功能开发添加了提交后，小红觉得她的功能OK了。如果团队使用Pull Requests，这时候可以发起一个用于合并到develop分支。否则她可以直接合并到她本地的develop分支后push到中央仓库： git pull origin developgit checkout developgit merge feature-logingit pushgit branch -d feature-login 第一条命令在合并功能前确保develop分支是最新的。注意，功能决不应该直接合并到master分支。冲突解决方法和集中式工作流一样。 小红开始准备发布这个时候小明正在实现他的功能，小红开始准备她的第一个项目正式发布。像功能开发一样，她用一个新的分支来做发布准备。这一步也确定了发布的版本号： git checkout -b release-0.1 develop 这个分支是清理发布、执行所有测试、更新文档和其它为下个发布做准备操作的地方，像是一个专门用于改善发布的功能分支。 只要小红创建这个分支并push到中央仓库，这个发布就是功能冻结的。任何不在develop分支中的新功能都推到下个发布循环中。 小红完成发布一旦准备好了对外发布，小红合并修改到master分支和develop分支上，删除发布分支。合并回develop分支很重要，因为在发布分支中已经提交的更新需要在后面的新功能中也要是可用的。另外，如果小红的团队要求Code Review，这是一个发起Pull Request的理想时机。 git checkout mastergit merge release-0.1git pushgit checkout developgit merge release-0.1git pushgit branch -d release-0.1 发布分支是作为功能开发（develop分支）和对外发布（master分支）间的缓冲。只要有合并到master分支，就应该打好Tag以方便跟踪。 git tag -a 0.1 -m “Initial public release” mastergit push –tags Git有提供各种勾子（hook），即仓库有事件发生时触发执行的脚本。可以配置一个勾子，在你push中央仓库的master分支时，自动构建好对外发布。 最终用户发现Bug对外发布后，小红回去和小明一起做下个发布的新功能开发，直到有最终用户开了一个Ticket抱怨当前版本的一个Bug。为了处理Bug，小红（或小明）从master分支上拉出了一个维护分支，提交修改以解决问题，然后直接合并回master分支：git checkout -b issue-#001 master# Fix the buggit checkout mastergit merge issue-#001git push 就像发布分支，维护分支中新加这些重要修改需要包含到develop分支中，所以小红要执行一个合并操作。然后就可以安全地删除这个分支了： git checkout developgit merge issue-#001git pushgit branch -d issue-#001 GitFlow的基本命令操作Gitflow安装1234# 1.curl -L -O https://raw.github.com/nvie/gitflow/develop/contrib/gitflow-installer.sh# 2.sudo bash gitflow-installer.sh 使用 初始化: git flow init 开始新Feature: git flow feature start MYFEATURE Publish一个Feature(也就是push到远程): git flow feature publish MYFEATURE 获取Publish的Feature: git flow feature pull origin MYFEATURE 完成一个Feature: git flow feature finish MYFEATURE 开始一个Release: git flow release start RELEASE [BASE] Publish一个Release: git flow release publish RELEASE 发布Release: git flow release finish RELEASE 别忘了git push –tags 开始一个Hotfix: git flow hotfix start VERSION [BASENAME] 发布一个Hotfix: git flow hotfix finish VERSIO 1git flow init 这个命令会进行一些默认的配置，可以自动创建上面介绍的所有分支：master、develop、feature、relase、hotfix等分支。 完成后当前所在分支就变成 develop. 任何开发都必须从 develop 开始 当进行新功能开发的时候： 1git flow feature start some_awesome_feature 完成功能开发之后: 1git flow feature finish some_awesome_feature 该命令将会把feature/some_awesome_feature合并到develope分支，然后删除功能(feature)分支。 将一个 feature 分支推到远程服务器 1git flow feature publish some_awesome_feature 或者 git push origin feature/some_awesome_feature 当你的功能点都完成时（需要发布新版本了），就基于develop创建一个发布(release)分支。 1git flow release start v0.1.0 当你在完成（finish)一个发布分支时，它会把你所作的修改合并到master分支，同时合并回develop分支，所以，你不需要担心你的master分支比develop分支更加超前。 当系统出现问题的时候，需要进行紧急修改的时候，就好基于master创建一个维护（hotfix）分支。 1git flow hotfix start v0.1.0 当你在完成（finish)一个维护分支时，它会把你所作的修改合并到master分支，同时合并回develop分支。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins部署项目-项目运行01]]></title>
    <url>%2F2019%2F06%2F22%2F2019-06-22-Jenkins%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE-%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[持续集成，持续交付第二章-项目运行01 GitLab连接Jenkins发布项目到gitlab上 创建项目 将本机项目中的.git文件删除 配置gitlab与本机连接的密钥 将本机里的项目发布到gitlab仓库中 注意的一个点:这里不能使用域名.只能使用ip地址.下面的jenkins克隆代码也是只能使用ip地址 GitLab连接Jenkins 进入jenkins容器 cd /usr/local/jenkins docker exec -it jenkins /bin/bash:进入容器,并以bash呈现,其实就是进入了终端 在容器中进入具有可执行权限的jenkins_hone目录 cd /var/jenkins_home/ 在容器中生成一个SSH密钥 ssh-keygen -t rsa -C &quot;hui@hui.com&quot; -b 4096 查看秘钥 cat /var/jenkins_home/.ssh/id_rsa.pub 将查到的密钥粘贴到gitlab中,起名为Jenkins 将gitlab中的项目克隆到/var/jenkins_home/目录下 git clone ssh://git@192.168.12.140:2222/hui/myshop.git 验证是否gitlab与jenkins连接 cd .ssh/,如果在.ssh目录下有known_hosts,则说明连接成功 新增一台机器这台机器我用于存放JDK(其实只需要JRE),Maven和tomcat。ip:192.168.12.146 需要在这台机器的/usr/local目录下新建一个jenkins,用于jenkins访问的目录 进入Jenkins页面 系统管理–&gt;系统设置–&gt;Publish over SSH 添加虚拟机的私钥 cat /var/jenkins_home/.ssh/id_rsa.pub 将秘钥复制到”key”中 点击新增 这里需要把刚刚创建的一台虚拟机新增进来,访问方式是SSH方式访问 点击”高级”,选上密码复选框,密码为新增这台虚拟机的开机密码.整体配置如下 点击Test Configuration进行测试,如果出现Success,则连接成功 最后点击应用–&gt;保存 使用Jenkins构建项目 新建任务,输入一个任务名称.我这里依然用了gitlab中的项目名称myshop,然后选择构建一个maven项目,点击确定 选择”丢弃旧的构建”,保持构建的最大个数填”10”,意思是每次都保留最新的10个构建,其他丢弃 选择”源码管理” 选择git,”Repository URL”填写gitlab中的项目地址,要把域名改为ip 然后点击应用–&gt;保持 点击”立即构建” 可以通过构建历史查看记录 也可以通过点击那个小红点查看控制台输出 这是个构建失败的例子,因为我没有配置maven和JDK 配置JDK和Maven 系统管理–&gt;全局工具配置 JDK,JDK的下载我是从oracle公司下载的,因此需要登录 Maven 应用–&gt;保存 再次回到”立即构建”,此时就会开始下载jdk和maven,然后构建项目 在”我的视图”里可以查看是一下情况,则构建成功 Jenkis连接gitlab中的项目标签 在gitlab的myshop项目中新建一个标签 点击标签,然后新建,填入标签名称:1.0.0 点击项目名称 进去后选择”配置” 选择参数化构建过程,配置如下,这步必须已经装上了Extended Choice Parameter plugin插件 Groovy Script的脚本文件 注意:要保证/var/jenkins_home/workspace/myshop路径正确 12def ver_keys = [ 'bash', '-c', 'cd /var/jenkins_home/workspace/myshop;git pull&gt;/dev/null; git remote prune origin &gt;/dev/null; git tag -l|sort -r |head -10 ' ]ver_keys.execute().text.tokenize('\n') 配置这个是为了通过gitlab的标签进行参数化构建 “源码管理”从git改为无 添加shell自动构建脚本 注意/var/jenkins_home/workspace/myshop路径别错了 12345echo $RELEASE_VERSIONcd /var/jenkins_home/workspace/myshopgit checkout $RELEASE_VERSIONgit pull origin $RELEASE_VERSIONmvn clean package 应用–&gt;保存 点击Build with Parameters开始构建,第一次需要同意运行脚本,同意后再次点击Build with Parameters开始构建]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>mysql</tag>
        <tag>redis</tag>
        <tag>nexus</tag>
        <tag>jekins</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins部署项目-环境搭建]]></title>
    <url>%2F2019%2F06%2F21%2F2019-06-20-Jenkins%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[持续集成，持续交付第一章-环境搭建 Jenkins部署项目-环境搭建部署环境gitlab 域名:gitlab.hui.com ip:192.168.12.140 配置:1-2-2mysql 域名:mysql.hui.com ip:192.168.12.141 配置:1-1-1nexus 域名:nexus.hui.com ip:192.168.12.142 配置:1-1-2redis 域名:redis.hui.com ip:192.168.12.143 配置:1-1-1jenkins 域名:jenkins.hui.com ip:192.168.12.144 配置:1-2-2harbor 域名:harbor.hui.com ip:192.168.12.145 配置:2-2-4 磁盘：40GJDK&amp;Maven&amp;tomcat 域名:utils.hui.com ip:192.168.12.146 配置:1-2-2k8s-base 域名:k8s-base.hui.com ip:192.168.12.150 配置:1-2-2 k8s的基础镜像k8s-master 域名:k8s-master.hui.com ip:192.168.12.151 配置:1-2-2 主节点k8s-node1 域名:k8s-node1.hui.com ip:192.168.12.152 配置:1-2-2 从节点k8s-node2 域名:k8s-node2.hui.com ip:192.168.12.153 配置:1-2-2 从节点project 域名:myproject.hui.com ip:192.168.12.160 配置讲解: 1-1-1:处理器数量为1,每个处理器的内核数量为1,内存为1. 其中的硬盘不做特殊说明，默认使用的是20GB. 以上配置是要求的最低配置,如果在使用过程中不够用时,需要再加 该配置需要的最低核心数为10,需要的最低内存数量为18 准备条件VMware 基础的base虚拟机一台.要求:虚拟机里有ssh,docker,docker-compose.其中docker-compose的版本最低要求1.8以上. 自制的一个网卡,网卡自制方式: 在VWware里选择编辑–&gt;虚拟网络编辑器–&gt;更改设置 将已经存在的网卡全部改为”仅主机模式” 添加网络–&gt;修改ip地址–&gt;改为NAT模式–&gt;应用–&gt;确定 在虚拟机里新建一个文件夹,把基础的base虚拟机(以下简称base)放进去,并将网卡修改为新设置的网卡 初始账号,密码和邮箱 账号:hui 密码:hui123456 邮箱:hui@hui.hui GitLab环境的搭建基础配置 右键base–&gt;管理–&gt;克隆–&gt;一路下一步(使用链接克隆)–&gt;改个名称和存储位置 编辑虚拟机配置–&gt;配置改为1-1-2.查看网卡是否是自己定义的网卡,不是就修改为自己设置的 修改本机(个人PC机器)DNS服务器地址为114.114.114.114 114.114.115.115 启动虚拟机 配置静态ip地址 vi /etc/netplan/50-cloud-init.yaml 如果出现以下信息,按”e”键就行了 修改如下: 执行netplan apply使文件生效 执行ping www.baidu.com验证网络,如果没有问题,就使用本机的XShll链接虚拟机 修改服务器名称为gitlab 1$ hostnamectl set-hostname gitlab 设置结束后还需要设置preserve-hostname:true.进入设置文件vi /etc/cloud/cloud.cfg设置即可 reboot重启电脑 将主机与域名配在一起.因为名称虚拟机名称改为了gitlab,所以可以通过以下配置,将ip地址与域名gitlab.hui.com联系到一起 1$ vi /etc/hosts 配置如下: 本机下载SwitchHosts.作用是在Windows机器上使用域名访问虚拟机.其是解决多个ip不污染系统的host文件. 修改权限:找到C:\Windows\System32\drivers\etc下的hosts文件.右键–&gt;属性–&gt;去掉”只读”,并将”安全”里的所有权限都打开 然后以管理员的身份运行SwitchHosts!.exe.新增一个rules–&gt;填入一个名称 配置(ip与域名间有两个空格),并打开开关 安装gitlab 检查docker和docker-compose是否正常 1234root@ubuntu:~# docker --versionDocker version 18.09.6, build 481bc77root@ubuntu:~# docker-compose --versiondocker-compose version 1.24.0, build 0aa5906 配置docker-compose.yml文件 1234567cd /usr/localmkdir gitlabcd gitlabvi docker-compose.yml docker-compose.yml 来源: https://funtl.com/zh/spring-cloud-alibaba-myshop/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD.html docker-compose.yml配置文件.其中将hostname改为hostname: &#39;gitlab.hui.com&#39;,将external_url改为external_url &#39;http://gitlab.hui.com:8080&#39; 123456789101112131415161718192021version: '3'services: web: image: 'twang2218/gitlab-ce-zh' restart: always hostname: 'gitlab.hui.com' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.hui.com:8080' gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8888 nginx['listen_port'] = 8080 ports: - '8080:8080' - '8443:443' - '2222:22' volumes: - ./config:/etc/gitlab - ./data:/var/opt/gitlab - ./logs:/var/log/gitlabi 启动docker-compose 1docker-compose up -d 镜像拉取结束后,使用docker-compose ps查看进程直到state的starting消失后gitlab才启动 如果等的有点急,可以通过docker logs -f 容器名称来查看具体进程 设置gitlab的账号,密码,邮箱.开始访问gitlab.hui.com:8080 账号:hui 密码:hui123456 邮箱:hui@hui.hui 第一步:设置密码界面,将以上密码填入就行 第二步:注册.将以上账号,密码,邮箱依次填入 汉化gitlab 右键个人小头标–&gt;settings–&gt;preferences–&gt;language 由于我的这个镜像是已经汉化过的,所以不用汉化了 创建组 点击左上角的gitlab–&gt;创建群组 创建项目 在已经创建的群组里创建项目 添加SSH公钥 项目创建成功后,会让添加SSH公钥 点击新建SSH公钥,然后点击generate one 选择该页面中的ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096命令来在本机上生成公钥 1ssh-keygen -t rsa -C "hui@hui.hui" -b 4096 执行过程如下图 复制公钥,粘贴到gitlab的Settings–&gt;SSH中 添加全局设置 12$ git config --global user.name "hui"$ git config --global user.email "hui@hui.hui" gitlab配置完成,接下来是整合Jenkins的过程了 MySql环境的搭建准备步骤和gitlab的基础配置是一样的 在修改服务器名称时改为： 1$ hostnamectl set-hostname mysql 安装mysql 检查docker和docker-compose是否正常 1234root@ubuntu:~# docker --versionDocker version 18.09.6, build 481bc77root@ubuntu:~# docker-compose --versiondocker-compose version 1.24.0, build 0aa5906 配置docker-compose.yml文件 1234567cd /usr/localmkdir mysqlcd mysqlvi docker-compose.yml docker-compose.yml来源: https://funtl.com/zh/spring-cloud-alibaba-myshop/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD.html 安装MySql8.x即可.配置文件如下 1234567891011121314151617181920212223version: '3.1'services:db: image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 123456 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysqladminer: image: adminer restart: always ports: - 8080:8080 启动docker-compose 1docker-compose up -d mysql的设置启动速度较快.可以使用docker-compose ps查看一下即可 使用http://mysql.hui.com:8080/在本机访问mysql 用户名:root 密码:123456 登录进去后可以创建数据库,导入.sql的文件以及导出 Nexus环境的搭建准备步骤和gitlab的基础配置是一样的 在修改服务器名称时改为： 1$ hostnamectl set-hostname nexus 安装Nexus 检查docker和docker-compose是否正常 1234root@ubuntu:~# docker --versionDocker version 18.09.6, build 481bc77root@ubuntu:~# docker-compose --versiondocker-compose version 1.24.0, build 0aa5906 配置docker-compose.yml文件 1234567cd /usr/localmkdir nexuscd nexusvi docker-compose.yml docker-compose.yml来源: https://funtl.com/zh/spring-cloud-alibaba-myshop/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD.html 安装Nexus.配置文件如下 12345678910111213version: '3.1'services:nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 8081:8081 volumes: - data:/nexus-datavolumes:data: 启动docker-compose 1docker-compose up -d nexus的设置启动速度较快.可以使用docker-compose ps查看一下即可 使用http://nexus.hui.com:8081/访问,登录 初始账号密码: 账号:admin 密码:admin123 注意事项:如果需要本地运行,本地需要安装maven,tomcat. Redis环境的搭建准备步骤和gitlab的基础配置是一样的 在修改服务器名称时改为： 1$ hostnamectl set-hostname redis 安装Redis 检查docker和docker-compose是否正常 1234root@ubuntu:~# docker --versionDocker version 18.09.6, build 481bc77root@ubuntu:~# docker-compose --versiondocker-compose version 1.24.0, build 0aa5906 配置docker-compose.yml文件 1234567cd /usr/localmkdir rediscd redisvi docker-compose.yml docker-compose.yml来源: https://funtl.com/zh/spring-cloud-alibaba-myshop/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD.html 安装redis.配置文件如下 将container_name: redis-master改为container_name: redis.来源中的redis是集群,我们没有用集群,所以就不需要起名带master了 1234567version: '3.1'services:master: image: redis container_name: redis ports: - 6379:6379 启动docker-compose 1docker-compose up -d redis的设置启动速度较快.可以使用docker-compose ps查看一下即可 redis似乎没有可以访问的地址 Jenkins环境的搭建准备步骤和gitlab的基础配置是一样的 在修改服务器名称时改为： 1$ hostnamectl set-hostname jenkins 安装Jenkins 检查docker和docker-compose是否正常 1234root@ubuntu:~# docker --versionDocker version 18.09.6, build 481bc77root@ubuntu:~# docker-compose --versiondocker-compose version 1.24.0, build 0aa5906 配置docker-compose.yml文件 1234567cd /usr/localmkdir jenkinscd jenkinsvi docker-compose.yml docker-compose.yml来源: https://funtl.com/zh/spring-cloud-alibaba-myshop/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD.html 安装Jenkins.配置文件如下 12345678910111213141516version: '3.1'services:jenkins: restart: always image: jenkinsci/jenkins container_name: jenkins ports: - 8080:8080 - 50000:50000 environment: TZ: Asia/Shanghai volumes: - data:/var/jenkins_homevolumes:data: 启动docker-compose 1docker-compose up -d jenkins的设置启动速度较快.可以使用docker-compose ps查看一下即可 使用http://jenkins.hui.com:8080访问jenkins jenkins的设置 设置密钥:提示给出的路径我没有找到.可以用一下简单的方法获取密钥 在/var/local/jenkins目录下执行docker logs -f jenkins.以下标注的地方就是密钥 选择插件安装 随便选择一个.我这里选择了第二个. 选择好后直接点击install安装.不用管是否安装上,先让其安装完,然后把没有装上的插件拍照截图,等进入系统后再逐个安装.我的安装情况如下: 点击Continue 创建第一个管理员用户 依然使用同一套账号密码邮箱: 账号:hui 密码:hui123456 邮箱:hui@hui.hui 示例配置 我这里只是将其配置为http://jenkins.hui.com:8080/jenkins 接下来一路确定就可以了 配置镜像加速 系统管理–&gt;插件管理–&gt;高级(Advanced)–&gt;升级站点 参考网站:https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/2.150/ 配置的最终URL:https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/2.150/update-center.json 点击提交–&gt;点击立即获取 汉化 系统管理–&gt;插件管理–&gt;可选插件(Available)–&gt;过滤,搜”Locale”–&gt;选中后点击直接安装 其实这里需要装两个插件:一个是Locale,另一个是Localization:Chinese(simplified).但是Localization:Chinese(simplified)在最初的时候给我安装过了,所以这里不用再装了 汉化过程: 系统管理–&gt;系统设置–&gt;Locale–&gt;Default language 填入 zh-CN,下面那个对号不用打勾 应用–&gt;保存 几个必装的插件 123Publish Over SSHMaven IntegrationExtensible Choice Parameter 逐个下载插件 这里介绍两种下载插件的方法: 第一种下载插件的方法: 系统管理–&gt;插件管理–&gt;可选插件(Available)–&gt;过滤,比对着前面没有下载上的插件逐个搜索,搜到的插件前面先打上对号,不安装,等全部找齐后,点击下载待重启后安装 待全部下载结束后.回到虚拟机里执行docker-compose restart重启jenkins 第二种下载插件的方法: 进入官网:https://plugins.jenkins.io/,输入要下载的插件名称搜索 点击某个插件页面进去,然后点击右上角的Archives,选择相应的版本下载.格式是.hpi 下载好后,进入jenkins中.系统管理–&gt;插件管理–&gt;高级–&gt;上传插件–&gt;选择下载的.hpi文件–&gt;上传–&gt;返回首页 Harbor环境的搭建准备步骤和gitlab的基础配置是一样的 在修改服务器名称时改为： 1$ hostnamectl set-hostname Harbor 安装Harbor 检查docker和docker-compose是否正常 1234root@ubuntu:~# docker --versionDocker version 18.09.6, build 481bc77root@ubuntu:~# docker-compose --versiondocker-compose version 1.24.0, build 0aa5906 下载harbor，采用离线的方式安装 下载地址：https://github.com/goharbor/harbor/releases,下载离线版的：Harbor offline installer 将harbor传到虚拟机中 在本机切换到harbor-offline-installer-v1.8.1.tgz的下载目录下,执行 scp harbor-offline-installer-v1.8.1.tgz root@192.168.12.145:/usr/local/ 在虚拟机解压harbor-offline-installer-v1.8.1.tgz tar -xzvf harbor-offline-installer-v1.8.1.tgz 将压缩包文件删除 rm -fr harbor-offline-installer-v1.8.1.tgz 安装harbor 进入解压好的harbor目录 cd harbor 修改harbor.yml vi harbor.yml 将hostname: reg.mydomain.com改为hostname: harbor.hui.com 解决无法登录问题:默认登录的网址是https://harbor.hui.com.是https而不是http.这样就出现了找不到的情况.解决方案 先执行以下: 123cat &gt; /etc/docker/daemon.json &lt;&lt; EOF&#123; "insecure-registries":["harbor.hui.com"] &#125;EOF 再执行./install.sh脚本开始安装 使用http://harbor.hui.com来访问harbor 初始用户名密码: 用户名:admin 密码:Harbor12345 push和pull 在本机haibor网页新建一个项目,选择公开即可 在虚拟机中登录harbor docker login harbor.hui.com 账号:admin 密码:Harbor12345 push镜像 push镜像的意思是把docker里的镜像push到harbor里,我这里下载了一个hello-world的镜像用于测试 docker pull hello-world 以下是官网提供的push方式: 例子: 先给镜像重新一个名称: docker tag hello-world:latest harbor.hui.com/myproject/hello-world:v1.0.0 然后push镜像 docker push harbor.hui.com/myproject/hello-world:v1.0.0 在本机刷新以下页面,可以看到harbor里已经有了myproject/hello-world:v1.0.0 pull镜像 pull镜像是把harbor里的镜像拉到docker里 测试步骤:先把docker里的hello-world镜像删除 docker rmi hello-world:latest docker rmi harbor.hui.com/myproject/hello-world:v1.0.0 pull镜像 docker pull harbor.hui.com/myproject/hello-world:v1.0.0 如果docker images可以看到刚刚拉取的镜像,就说明没有问题了 Kubernetes的搭建Kubernetes使用一主两从的方式搭建 首先先完整克隆一个基础的Kubernetes虚拟机,然后在这台机器上做一些基础配置,这些配置是主节点和从节点的机器都要配置的.基础配置后,克隆时就不需要每台都配置了. Kubernetes的基础配置参考网址:https://funtl.com/zh/service-mesh-kubernetes/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4.html 检查docker,docker-compose,交换空间.我这里用的基础镜像已经全部配过了,所以不会有大的问题,不过还是要检查一下.(基础虚拟机镜像的配置参考我的博客虚拟机那部分) 基础镜像ip我使用的是192.168.12.150 其他基础的准备工作和gitlab的准备工作一样 安装 kubeadm，kubelet，kubectl 12345678910111213# 安装系统工具apt-get update &amp;&amp; apt-get install -y apt-transport-https# 安装 GPG 证书curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -# 写入软件源；注意：我们用系统代号为 bionic，但目前阿里云不支持，所以沿用 16.04 的 xenialcat &lt;&lt; EOF &gt;/etc/apt/sources.list.d/kubernetes.list&gt; deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&gt; EOF# 安装apt-get update &amp;&amp; apt-get install -y kubelet kubeadm kubectl 执行结束后,在最后可以看到一些版本号信息 12345Setting up kubelet (1.15.0-00) ...Created symlink /etc/systemd/system/multi-user.target.wants/kubelet.service → /lib/systemd/system/kubelet.service.Setting up kubectl (1.15.0-00) ...Processing triggers for man-db (2.8.3-2ubuntu0.1) ...Setting up kubeadm (1.15.0-00) ... 在这里要记住kubeadm的版本号为1.15.0-00,因为kubernetes的版本号要和他的一致 同步时间 设置时区 $ dpkg-reconfigure tzdata 选择 Asia（亚洲）–&gt;选择 Shanghai（上海） 时间同步 12345678# 安装 ntpdateapt-get install ntpdate# 设置系统时间与网络时间同步（cn.pool.ntp.org 位于中国的公共 NTP 服务器）ntpdate cn.pool.ntp.org# 将系统时间写入硬件时间hwclock --systohc 如果在执行apt-get install ntpdate中遇到以下问题 12E: Could not get lock /var/lib/dpkg/lock-frontend - open (11: Resource temporarily unavailable)E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it? 可以通过下面的方式解决 123sudo rm /var/lib/apt/lists/locksudo rm /var/cache/apt/archives/locksudo apt update 然后再执行apt-get install ntpdate 确认时间 $ date 输出以下格式就是正常的 Sat Jun 22 12:23:16 CST 2019 配置 IPVS 123456789101112131415161718192021222324252627# 安装系统工具apt-get install -y ipset ipvsadm# 配置并加载 IPVS 模块mkdir -p /etc/sysconfig/modules/vi /etc/sysconfig/modules/ipvs.modules# 输入如下内容#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4# 执行脚本，注意：如果重启虚拟机则需要重新运行该脚本chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4# 执行脚本输出如下ip_vs_sh 16384 0ip_vs_wrr 16384 0ip_vs_rr 16384 0ip_vs 147456 6 ip_vs_rr,ip_vs_sh,ip_vs_wrrnf_conntrack_ipv4 16384 3nf_defrag_ipv4 16384 1 nf_conntrack_ipv4nf_conntrack 131072 8 xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_ipv4,nf_nat,ipt_MASQUERADE,nf_nat_ipv4,nf_conntrack_netlink,ip_vslibcrc32c 16384 4 nf_conntrack,nf_nat,raid456,ip_vs 注意:每次重启虚拟机,主节点和从节点虚拟机都要重新执行chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4 配置内核参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 配置参数vi /etc/sysctl.d/k8s.conf# 输入如下内容net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_nonlocal_bind = 1net.ipv4.ip_forward = 1vm.swappiness=0# 应用参数sysctl --system# 应用参数输出如下（找到 Applying /etc/sysctl.d/k8s.conf 开头的日志）* Applying /etc/sysctl.d/10-console-messages.conf ...kernel.printk = 4 4 1 7* Applying /etc/sysctl.d/10-ipv6-privacy.conf ...* Applying /etc/sysctl.d/10-kernel-hardening.conf ...kernel.kptr_restrict = 1* Applying /etc/sysctl.d/10-link-restrictions.conf ...fs.protected_hardlinks = 1fs.protected_symlinks = 1* Applying /etc/sysctl.d/10-lxd-inotify.conf ...fs.inotify.max_user_instances = 1024* Applying /etc/sysctl.d/10-magic-sysrq.conf ...kernel.sysrq = 176* Applying /etc/sysctl.d/10-network-security.conf ...net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.all.rp_filter = 1net.ipv4.tcp_syncookies = 1* Applying /etc/sysctl.d/10-ptrace.conf ...kernel.yama.ptrace_scope = 1* Applying /etc/sysctl.d/10-zeropage.conf ...vm.mmap_min_addr = 65536* Applying /usr/lib/sysctl.d/50-default.conf ...net.ipv4.conf.all.promote_secondaries = 1net.core.default_qdisc = fq_codel* Applying /etc/sysctl.d/99-sysctl.conf ...* Applying /etc/sysctl.d/k8s.conf ...net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_nonlocal_bind = 1net.ipv4.ip_forward = 1vm.swappiness = 0* Applying /etc/sysctl.conf ... 至此,基础的kubernetes镜像已经做好,先做个快照,接下来链接克隆3台机器,一个为master节点机器,两个node节点机器 Kubernetes集群的搭建(在master机器上操作) 先对3台虚拟机进行基础配置,注意就是修改一下静态ip和域名 master:192.168.12.151 k8s-master.hui.com node1: 192.168.12.152 k8s-node1.hui.com node2: 192.168.12.153 k8s-node2.hui.com 在master节点上配置kubeadm 参考网址: https://funtl.com/zh/service-mesh-kubernetes/%E9%85%8D%E7%BD%AE-kubeadm.html 在/usr/local下创建一个名为kubernetes新的文件夹 12mkdir -p /usr/local/kubernetescd /usr/local/kubernetes 创建并修改配置 12# 导出配置文件kubeadm config print init-defaults --kubeconfig ClusterConfiguration &gt; kubeadm.yml 这步执行结束后会在/usr/local/kubernetes文件夹下得到一个kubeadm.yml配置文件 修改配置文件的一些参数: 1)advertiseAddress: 1.2.3.4,将ip地址修改为本机ip地址 修改结果:advertiseAddress: 192.168.12.151 2)将imageRepository: k8s.gcr.io修改为imageRepository: registry.aliyuncs.com/google_containers 3)将kubernetesVersion: v1.14.0的版本改成和基础配置里的kubeadm (1.15.0-00)的版本一样,修改结果为kubernetesVersion: v1.15.0 4)添加Calico网段,在dnsDomain和serviceSubnet之间添加podSubnet: “10.244.0.0/16”具体如下: 1234dnsDomain: cluster.local# 配置成 Calico 的默认网段podSubnet: "10.244.0.0/16"serviceSubnet: 10.96.0.0/12 5)在最后添加开启 IPVS 模式 1234567---# 开启 IPVS 模式apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: KubeProxyConfigurationfeatureGates:SupportIPVSProxyMode: truemode: ipvs 查看和拉取镜像 1234# 查看所需镜像列表kubeadm config images list --config kubeadm.yml# 拉取镜像kubeadm config images pull --config kubeadm.yml 使用 kubeadm 搭建 kubernetes 集群 除了将node节点加入master的一条命令外,其他都在master节点上执行 参考链接:https://funtl.com/zh/service-mesh-kubernetes/%E4%BD%BF%E7%94%A8-kubeadm.html 安装 kubernetes 主节点 kubeadm init --config=kubeadm.yml --experimental-upload-certs | tee kubeadm-init.log 成功后会看到以下内容 12345678910111213141516Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user:mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.12.151:6443 --token abcdef.0123456789abcdef \ --discovery-token-ca-cert-hash sha256:2f25eb2088d88bda22946e63de889557dca90f4a2180d0d0495d5ff4f71a4db0 按照以上内容的提示信息配置 kubectl 123mkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config 验证是否成功 12345kubectl get node# 能够打印出节点信息即表示成功NAME STATUS ROLES AGE VERSIONkubernetes-master NotReady master 8m40s v1.14.1 接下来的一步要在node节点的机器上操作.执行以上提示信息的最后一句将node节点的机器加入到master节点中 12kubeadm join 192.168.12.151:6443 --token abcdef.0123456789abcdef \ --discovery-token-ca-cert-hash sha256:2f25eb2088d88bda22946e63de889557dca90f4a2180d0d0495d5ff4f71a4db0 验证是否加入成功 1234567kubectl get node# 能够打印出节点信息即表示成功NAME STATUS ROLES AGE VERSIONk8s-base NotReady master 8m1s v1.15.0k8s-node1 NotReady &lt;none&gt; 56s v1.15.0k8s-node2 NotReady &lt;none&gt; 23s v1.15.0 配置网络参考网址:https://funtl.com/zh/service-mesh-kubernetes/%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C.html 安装网络插件 Calico 12# 在 Master 节点操作即可kubectl apply -f https://docs.projectcalico.org/v3.7/manifests/calico.yaml 确认安装是否成功 123456789101112131415watch kubectl get pods --all-namespaces# 需要等待所有状态为 Running，注意时间可能较久，3 - 5 分钟的样子Every 2.0s: kubectl get pods --all-namespaces kubernetes-master: Fri May 10 18:16:51 2019NAMESPACE NAME READY STATUS RESTARTS AGEkube-system calico-kube-controllers-8646dd497f-g2lln 1/1 Running 0 50mkube-system calico-node-8jrtp 1/1 Running 0 50mkube-system coredns-8686dcc4fd-mhwfn 1/1 Running 0 51mkube-system coredns-8686dcc4fd-xsxwk 1/1 Running 0 51mkube-system etcd-kubernetes-master 1/1 Running 0 50mkube-system kube-apiserver-kubernetes-master 1/1 Running 0 51mkube-system kube-controller-manager-kubernetes-master 1/1 Running 0 51mkube-system kube-proxy-p8mdw 1/1 Running 0 51mkube-system kube-scheduler-kubernetes-master 1/1 Running 0 51m 配置Calico.yaml文件 下载Calico.yaml 在/usr/local/kubernetes下执行 wget https://docs.projectcalico.org/V3.7/manifests/calico.yaml 查看该文件夹下有没有calico.yaml的文件 然后编辑该文件vi calico.yaml.文件较长,可以在编辑文件里按\CALICO_IPV4POOL_CIDR,然后按确定键直接锁定位置 按i编辑,将value的值该为:10.244.0.0/16 最后注意事项 每次重启虚拟机,主节点和从节点虚拟机都要重新执行chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4 至此基本环境已部署完毕]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>mysql</tag>
        <tag>redis</tag>
        <tag>nexus</tag>
        <tag>jekins</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell基本命令]]></title>
    <url>%2F2019%2F06%2F19%2F2019-06-19-Shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本文是一篇关于Shell脚本语言的基本命令文档 shell123456789101112131415161718-e filename 如果 filename存在，则为真-d filename 如果 filename为目录，则为真-f filename 如果 filename为常规文件，则为真-L filename 如果 filename为符号链接，则为真-r filename 如果 filename可读，则为真-w filename 如果 filename可写，则为真-x filename 如果 filename可执行，则为真-s filename 如果文件长度不为0，则为真-h filename 如果文件是软链接，则为真filename1 -nt filename2 如果 filename1比 filename2新，则为真。filename1 -ot filename2 如果 filename1比 filename2旧，则为真。-eq 等于-ne 不等于-gt 大于-ge 大于等于-lt 小于-le 小于等于至于！号那就是取非了呗！ expect123456789101112131415161718192021222324252627spawn 调用要执行的命令expect 等待命令提示信息的出现，也就是捕捉用户输入的提示：send 发送需要交互的值，替代了用户手动输入内容set 设置变量值interact 执行完成后保持交互状态，把控制权交给控制台expect eof 这个一定要加，与spawn对应表示捕获终端输出信息终止expect脚本必须以interact或expect eof结束，执行自动化任务通常expect eof就够了设置expect永不超时set timeout -1设置expect 300秒超时，如果超过300没有expect内容出现，则推出set timeout 300expect编写语法，expect使用的是tcl语法。一条Tcl命令由空格分割的单词组成. 其中, 第一个单词是命令名称, 其余的是命令参数cmd arg arg arg$符号代表变量的值. 在本例中, 变量名称是foo.$foo方括号执行了一个嵌套命令. 例如, 如果你想传递一个命令的结果作为另外一个命令的参数, 那么你使用这个符号[cmd arg]双引号把词组标记为命令的一个参数. &quot;$&quot;符号和方括号在双引号内仍被解释&quot;some stuff&quot;大括号也把词组标记为命令的一个参数. 但是, 其他符号在大括号内不被解释&#123;some stuff&#125;反斜线符号是用来引用特殊符号. 例如：n 代表换行. 反斜线符号也被用来关闭&quot;$&quot;符号, 引号,方括号和大括号的特殊含义 使用shell编写的科学上网的脚本开启 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/expect#user loginset user rootset host 192.168.xx.xset password *******set timeout 60spawn ssh $user@$hostexpect "password:"send "$password\n"expect "~#"send "monlor\n"expect "请输入你的选择："send "04\n"expect "1/0"send "1\n"expect "1/0"send "0\n"expect "1/0"send "0\n"expect "1/0"send "0\n"expect "1/0"send "0\n"expect "~#"send "exit\n"interact 关闭 123456789101112131415161718192021222324252627282930#!/usr/bin/expect# user layoutset user rootset host 192.168.xx.xset password *******set timeout 60spawn ssh $user@$hostexpect "password:"send "$password\n"expect "~#"send "monlor\n"expect "请输入你的选择："send "04\n"expect "1/0"send "0\n"expect "1/0"send "0\n"expect "~#"send "exit\n"interact]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序法]]></title>
    <url>%2F2019%2F06%2F13%2F2019-06-12-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这是一篇关于选择排序的方法 选择排序文字解释选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 动图展示 Java代码实现1234567891011121314151617181920212223242526272829public int[] select(int[] arr)&#123; int min; //只需要执行arr.length-1次 for (int i=0;i&lt;arr.length-1;i++)&#123; int index=0; min=arr[i]; //比较次数逐次递减 for (int j=arr.length-1-i;j&gt;0;j--)&#123; /* 判断： 如果min大小接下来的值，将接下来的值赋给min,并记下该索引的位置 否则继续迭代 */ if (min&gt;arr[arr.length-j])&#123; min=arr[arr.length-j]; index=arr.length-j; &#125; &#125; //交换索引为index和最初的那个值的位置 if (index!=0)&#123; int temp; temp=arr[i]; arr[i]=arr[index]; arr[index]=temp; &#125; &#125; return arr; &#125; 时间复杂度选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间 稳定性选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[web.xml文件头声明]]></title>
    <url>%2F2019%2F06%2F12%2F2019-06-12-web-xml%E6%96%87%E4%BB%B6%E5%A4%B4%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[本文是一篇关于web.xml文件头声明的各个版本的总结 web.xml文件头声明各个版本参考 Servlet 3.1 Java EE 7 XML schema, namespace is http://xmlns.jcp.org/xml/ns/javaee/ 123456&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;/web-app&gt; Servlet 3.0 Java EE 6 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt;&lt;/web-app&gt; Servlet 2.5 Java EE 5 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;&lt;/web-app&gt; Servlet 2.4 J2EE 1.4 XML schema, namespace is http://java.sun.com/xml/ns/j2ee 12345678&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" version="2.4"&gt; &lt;display-name&gt;Servlet 2.4 Web Application&lt;/display-name&gt;&lt;/web-app&gt; Servlet 2.3 J2EE 1.3 DTDs schema. This web.xml file is too old, highly recommend you to upgrade it. 1234567&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Servlet 2.3 Web Application&lt;/display-name&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>web.xml</category>
      </categories>
      <tags>
        <tag>文件头</tag>
        <tag>版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven整合SSM]]></title>
    <url>%2F2019%2F06%2F12%2F2019-06-12-Maven%E6%95%B4%E5%90%88SSM%2F</url>
    <content type="text"><![CDATA[本文是一篇关于Maven整合SSM的依赖配置文件 Maven中的SSM的项目依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;!-- 锁定jar包版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- 项目依赖jar包 --&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 添加tomcat7插件 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 注意：被锁定的jar包在dependencyManagement标签内和外部都要有一份，因为被锁定的jar包是不能生成真正的jar包的。只有在dependencyManagement外部的依赖配置文件才能生成真正的jar包。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2019%2F06%2F12%2F2019-06-12-Maven%2F</url>
    <content type="text"><![CDATA[本文是一篇关于Maven的文件 Maven下载和安装Maven下载地址：http://maven.apache.org/download.cgi 安装地址：http://maven.apache.org/install.html maven的中央仓库：http://repo1.maven.org/maven2/ 修改maven中央仓库输入mvn --version可以查看到maven的安装位置 12345Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)Maven home: /usr/local/Cellar/maven/3.6.0/libexecJava version: 1.8.0_202, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: "mac os x", version: "10.13.6", arch: "x86_64", family: "mac" 然后cd到Maven home $ cd /usr/local/Cellar/maven/3.6.0/libexec maven的配置文件settings.xml在该目录下的conf下 然后在镜像的配置文件下添加以下配置 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 具体如下： 123456789101112131415161718192021&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; Maven的目录介绍bin目录 mvn.bat(以run方式运行项目)、mvnDebug.bat(以debug方式运行项目) boot目录 maven运行需要的加载类 conf目录 settings.xml整个maven工具核心配置文件 lib目录 maven运行依赖jar包 Maven本地仓库的配置在MAVE_HOME/conf/settings.xml文件中配置本地仓库 &lt;localRepository&gt;/Users/wanghui/mvn/repository&lt;/localRepository&gt; 在控制台上输入mvn --version就可以看到MAVE_HOME 123456$ mvn --versionApache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)Maven home: /usr/local/Cellar/maven/3.6.0/libexec //这里就是MAVE_HOME位置Java version: 1.8.0_202, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: "mac os x", version: "10.13.6", arch: "x86_64", family: "mac" Maven项目工程目录约定创建一个maven项目 12345678910111213Project | src | | main | | | java ----存放项目的.java文件 | | | resources ----存放项目资源文件，如spring，hibernate配置文件 | webapp ----web工程的主目录 | WEB-INF | web.xml | test | java ----存放所有测试.java文件，入JUnit测试类 | resources ----测试资源文件 | target | pom.xml ----maven项目核心配置文件 Maven的常用命令compile:编译，将.java文件编译为.class文件，并存放在target目录下 test：测试 clear：清理命令，删除target目录的内容 package：打包命令，对java工程打成jar包，对web工程打成war包 install：执行install将maven打成jar包或war包发布到本地仓库 Maven在idea里的配置 maven工程的jar包冲突问题的解决方式maven的jar包冲突原理： 123A-&gt;B-&gt;C-&gt;D1(log 15.0)：A中包含对B的依赖，B中包含对C的依赖，C中包含对D1的依赖，假设是D1是日志jar包，version为15.0E-&gt;F-&gt;D2(log 16.0)：E中包含对F的依赖，F包含对D2的依赖，假设是D2是同一个日志jar包，version为16.0 当pom.xml文件中引入A、E两个依赖后，根据Maven传递依赖的原则，D1、D2都会被引入，而D1、D2是同一个依赖D的不同版本。当我们在调用D2中的method1()方法，而D1中是15.0版本（method1可能是D升级后增加的方法），可能没有这个方法，这样JVM在加载A中D1依赖的时候，找不到method1方法，就会报NoSuchMethodError的错误，此时就产生了jar包冲突。 注：如果在调用method2()方法的时候，D1、D2都含有这个方法（且升级的版本D2没有改动这个方法，这样即使D有多个版本，也不会产生版本冲突的问题。） 解决jar包冲突的方案： 方案一： 第一声明优先原则：哪个jar包的坐标在靠上的位置，这个jar包就是先声明的。先声明的jar包坐标下的依赖包，可以优先进入项目中。 方案二： 直接依赖：项目中直接导入的jar包，就是该项目的直接依赖包传递依赖：项目中没有直接导入的jar包，可以通过项目直接依赖jar包传递到项目中 路径就近优先原则。直接依赖路径比传递依赖路径近，那么最终项目进入的jar包会是路径近的直接依赖 方案三：(推荐使用) 直接排除法 当我们要排除某个jar包下的依赖包，在配置exclusions标签的时候，内部可以不写版本号。因为此时依赖包使用的版本和默认的本jar包的版本一样 例如以下配置：spring-beans使用的是5.1.5.RELEASE，其所依赖的spring-core版本也是5.1.5.RELEASE。spring-context版本4.3.22.RELEASE，其所依赖的spring-core版本也是4.3.22.RELEASE。根据就近原则spring-core版本应该是5.1.5.RELEASE。因为添加了spring-core的exclusion，所以5.1.5.RELEASE的版本失效。最终spring-core的版本为4.3.22.RELEASE。 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.22.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 总结： exclusion的实效权限最大，实效后就不在有对应的版本信息。然后是直接依赖，存在直接依赖时，直接依赖会&gt;就近原则，即是有直接依赖的话，无论近远，都用的直接依赖，如果都不存在直接依赖，存在的都是传递依赖，这时才使用就近原则。 jar包的锁定标签用于锁定jar包 例如B依赖A，A是父工程。此时如果不对A中的部分jar包锁定，如果B中有对应的其他版本的jar包，B工程中会优先使用自己的jar包。如果对A中的部分jar包采用dependencyManagement标签锁定，B只能使用A中被锁定的版本的jar包 锁定的写法： 12345678&lt;dependencyManagement&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合配置文件]]></title>
    <url>%2F2019%2F06%2F11%2F2019-06-11-SSM%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[这是一篇关于SSM整合的配置文件 SSM框架整合整合思路Dao层 1.SqlMapConfig.xml,空文件即可，但是需要文件头 2.applicationContext.xml a.数据库连接 b.SqlSessionFactory对象，需要spring和mybatis整合包下的 c.配置mapper文件扫描器 Service层 1.applicationContext-service.xml包扫描器，扫描@service注解的类 2.applicationContext-trans.xml配置事务 Controller层 springmvc.xml a.包扫描器，扫描@Controller注解的类 b.配置注解驱动 c.配置视图解析器 Web.xml 1.配置spring 2.配置springmvc 3.配置前端控制器 整体配置文件Dao层 1.SqlMapConfig.xml,空文件即可，但是需要文件头 123456&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; 2.applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置 读取properties文件 jdbc.properties --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt; &lt;!-- 配置 数据源 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory --&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 设置MyBatis核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml" /&gt; &lt;!-- 设置数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!--配置别名包扫描--&gt; &lt;property name="typeAliasesPackage" value="com.hui.pojo"/&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 设置Mapper扫描包 --&gt; &lt;property name="basePackage" value="com.hui.mapper" /&gt; &lt;/bean&gt;&lt;/beans&gt; jdbc.properties的配置文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://192.1468.31.225:3306/crm?characterEncoding=utf-8jdbc.username=rootjdbc.password=123456 log4j.properties的配置文件 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n Service层 1.applicationContext-service.xml包扫描器，扫描@service注解的类 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置@Service类的包扫描 --&gt; &lt;context:component-scan base-package="com.hui.service" /&gt;&lt;/beans&gt; 2.applicationContext-trans.xml配置事务 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED" /&gt; &lt;tx:method name="insert*" propagation="REQUIRED" /&gt; &lt;tx:method name="add*" propagation="REQUIRED" /&gt; &lt;tx:method name="create*" propagation="REQUIRED" /&gt; &lt;tx:method name="delete*" propagation="REQUIRED" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" /&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* com.hui.service.*.*(..))" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; Controller层 springmvc.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置Controller扫描 --&gt; &lt;context:component-scan base-package="com.hui.controller" /&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; Web.xml 1.配置spring 2.配置springmvc 3.配置前端控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;display-name&gt;crm&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置spring --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置监听器加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置过滤器，解决post的乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--设置编码为utf-8,这部分可以不写--&gt; &lt;!--&lt;init-param&gt;--&gt; &lt;!--&lt;param-name&gt;encoding&lt;/param-name&gt;--&gt; &lt;!--&lt;param-value&gt;UTF-8&lt;/param-value&gt;--&gt; &lt;!--&lt;/init-param&gt;--&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置SpringMVC --&gt; &lt;servlet&gt; &lt;servlet-name&gt;crm&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- load-on-startup配置springmvc什么时候启动，参数必须为整数 --&gt; &lt;!-- 如果为0或者大于0，则springMVC随着tomcat容器启动而启动 --&gt; &lt;!-- 如果小于0，则在第一次请求进来的时候启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;crm&lt;/servlet-name&gt; &lt;!-- 所有的请求都进入springMVC --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 目录图]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序法]]></title>
    <url>%2F2019%2F06%2F09%2F2019-06-08-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这是一篇关于插入排序的方法 插入排序文字解释 插入排序是将数组分成两个数组，左边的为有序数组，右边的为无序数组 第一步，选择数组的第一个选择作为有序数组，然后拿该无序数组的第一个元素和它比较 从有序数组的最大的元素进行比较，如果比其大，就直接跳出循环 否则，将数组向后移动，最后将该数值插入到比较的大的元素的右边 动图展示 代码展示123456789101112131415161718192021222324252627public int[] insertSort(int[] arr)&#123; /* 该for循环把数组分成两部分 左边已经排好的序，右边为未排好的序 */ for (int i=1;i&lt;arr.length;i++)&#123; //记录排序与未排序的分割点temp(temp为下一个排序对象) int temp=arr[i]; /* 第二个for循环 将排序对象temp与已排序数组比较，这里遍历的是已排序的数组 如果temp比最近左边的数大时，直接结束本次循环，进行下一个排序 否则比左边这个数小时，将这个数右移，腾出这个数的位置 */ int j; for (j=i-1;j&gt;=0;j--)&#123; if (temp&gt;arr[j])&#123; break; &#125;else &#123; arr[j+1]=arr[j]; &#125; &#125; arr[j+1]=temp; &#125; return arr; &#125; 复杂度分析 最好的情况O(n) 最差的情况O(n²)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>插入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序法]]></title>
    <url>%2F2019%2F06%2F09%2F2019-06-08-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这是一篇关于冒泡排序的方法 冒泡排序文字解释对于一组包含n个数据的记录，冒泡排序在最坏的情况下需要进行n-1趟排序 第1趟：依次比较0和1、1和2、2和3…（n-2）和（n-1）索引的元素，如果发现第1个数据大于第2个数据，交换他们，经过第1趟排序，最大的元素排到了最后 第2趟：依次比较0和1、1和2、2和3…（n-3）和（n-3）索引的元素，如果发现第1个数据大于第2个数据，交换他们，经过第2趟排序，第二大的元素排到了倒数第二个位置… 第n-1趟：比较0和1索引的元素，如果发现第1个数据大于第2个数据，交换他们，经过第n-1趟排序，第二小的元素排到了第二个位置 动图展示 Java代码实现12345678910111213public int[] sort(int[] arr)&#123; for (int i=1;i&lt;arr.length;i++)&#123; for (int j=i;j&lt;arr.length-1;j++)&#123; int temp; if (arr[j]&gt;arr[j+1])&#123; temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; return arr; &#125; 时间复杂度时间复杂度：O(n²) 空间复杂度：O(1)，只需要一个额外空间用于交换 稳定性：冒泡排序是稳定的排序算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01_CRM资料收集]]></title>
    <url>%2F2019%2F06%2F04%2F2019-06-04-01-CRM%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[01_CRM的第一版资料 CRM项目设计CRM概述CRM：Customer Relationship Management 最终目标：吸引新客户，保留老客户以及将已有客户转为忠实客户，增强市场。 CRM:以客户为中心，客户需要什么，我就给他提供什么 CRM的两个任务： 1.获取客户 2.提高客户忠诚度 客户信息处理技术： 1.数据仓库 2.商业智能 3.知识发现 CRM是一个获取保持和增加可获利客户的方法和过程 CRM是企业业务流程的管理 CRM的核心步骤： 1.市场营销 2.销售 3.客户服务 4.技术支持 CRM的模块： 1.客户资源管理 2。销售管理 3.客户服务管理 4.日常事务管理 CRM对网络的要求： 公网和内网都可以实现 CRM的手段： 判断，选择，争取和保持客户所需的全部商业过程，对客户资料详细分析 CRM分类： 操作型：业务流程、信息记录、提供便捷的操作、人性化的界面 分析型：基于大量的企业日常数据，对数据挖掘分析，找出客户产品、服务的特征，从而修正企业的产品策略、市场策略。 CRM按功能分： 市场营销中的客户关系管理 分析目标群体：客户行业、职业、年龄、地域等 活动–&gt;产生/销售–&gt;报表–&gt;决策 销售过程中的客户关系管理 包括： 1234567潜在客户客户联系人业务机会订单汇款单报表统计图 业务员要做的 123456789记录沟通内容建立日程安排查询预约提醒快速浏览客户数据大额业务提醒销售漏斗分析业绩指标统计业务阶段划分客户服务过程中的客户关系管理 客户服务过程中的客户关系管理 目的： 12获的问题客户信息客户历史问题记录 主要功能： 1234客户反馈解决方案满意度调查呼叫中心 其它功能： 123办公管理行政管理进销存 运行范围业务员 客户信息的录入和维护的方式 123456789101112131415161718名片其他途径``` &gt; 要求：能及时对电话，地址等信息变更* 练习记录的录入的方式：```markdown电话邮件即时通知上门拜访公司网站电子邮件实时聊天营销材料最近社交媒体 投价单的录入信息 123基本客户信息沟通信息报价信息 要求：最好形成可打印的模板 业务员日常功能 客户联系提醒 1234今天或明天应联系客户逾期未联系客户逾期未下单客户长期没有业务往来客户 客户资料查询和统计分析 按客户名称关键词模糊查询，防止撞单 每天客户联系拜访情况的查询和分析 业绩查询和统计 应收款的提醒 工资，提成和费用的查询 销售助理 合同订单录入 收到传真订单和签订销售合同后凯撒录入系统 1234订购产品的型号数量单价金额 出货单的录入 录入收获单 123出货日期出货仓出货产品明细 注：如果以前录过，可以将录入信息数据导出模板使用 销售助理日常适用 订单查询及交货提醒 统计销售部门业绩 打印出货单 财务主管 收款后做收款处理，冲销应收款 付款后做付款处理，冲销应付款 录企业运营的各种费用 123456房租水电费办公支出员工工资提成奖金各种销售费用 日常使用 应收款提醒 12日、周有哪些应收款逾期应收款 逾期应收款日期：30天内，30～60天，60～90天，90～180天，180天以上 应收款统计分析 123哪些客户应收款比例大哪些用户逾期金额超额哪些用户账龄过长 应收/付款查询和统计，统计任一时期收/付款进账/出账明细，用图表显示 123按收/付款方式按业务员按年/月 费用查询统计，查各类费用，明细支出情况，用图标显示 1234按费用大类费用项目按年/月按业务员 以上核心：数据哪来？–&gt; 怎么处理 –&gt; 怎么展示 采购员 采购订单录入 12供应商名称产品明细 要求：可打印出模板 采购收获单 1收货信息 如果已有相应订单信息，可直接导出使用 客户关怀 客户服务 12产品信息服务建议 产品质量 123符合有关标准适合客户使用保证安全可靠 服务质量 1客户体验 售后服务 1234售后查询投诉维护修理 一些问题解决方案 遗忘老客户 数据–&gt;市场预测分析–&gt;制定计划和目标–&gt;激励销售人员 客户信息散，管理凌乱 企业资源分类 123客户竞争对手合作伙伴 软件灵活性差，开发升级难 企业自己要有强大的个性化自定制功能 指标客户概述分析 profiling 1234客户层次客户风险客户爱好客户习惯 客户忠诚分析 persistency 客户对产品或商业机构 123信用程度持久性变动情况 客户利润分析 profitability 消费产品 123边缘利润总利润净利润 客户性能分析 performance 消费产品的消费额 123种类渠道销售地点 客户未来分析 prospecting 12客户数量客户类别 客户产品分析 product 123产品设计关联性供应链 客户促销分析 promotion 12广告寻传 主要步骤 确定业务计划 建立CRM员工队伍 评估销售，服务过程 明确实际需求 销售管理人员 123市场预测销售渠道管理销售报告的提交 销售人员 1234销售额销售建议产品目录客户资料 选择供应商 开发与部署 呼叫中心：集中公司的一些信息资料提供客户剖析，业务剖析，找出有价值用户，将其转化为忠实客户 吸引新客户方法 市场调查，收集客户名单 公司活动，抽奖 开发已签单客户，寻求转介绍 10C 1.客户轮廓 customer profile 123456人口统计信息消费心理特征消费需求消费行为模式交易记录信用 客户知识 customer knowledge 客户区隔 customer segmentation 区分客户 12消费者对产品/服务(p/s)的相似欲望与需求客户获利率 客户化/定制化 customization 针对单一顾客，量身定制 123一对一的价格一对一的促销一对一的通路 大量营销 –&gt; 区隔营销 –&gt; 一对一营销 客户价值 customer value 从特定p/s获得利益集合 1234产品价值服务价值员工友谊价值品牌价值 客户满意度 customer satisfaction 顾客发展 customer development 针对老客户提供荷包贡献率(Wallet Ration)，方法： 12交叉销售：推荐其他产品高级销售：推荐本产品的高级版 客户保留率 customer retention 不让老客户流失的方法，产品需要 123优秀贴心量身订购 客户赢取率 customer acquistion 比竞争对手更好的产品 客户获利率 customer profitability 客户终生对企业贡献的纯利润 第一个CRM SugarCRM 加个功能：社交媒体 社交CRM：Base，Nutshell 仪表盘：客户信息，过去销售，先前的营销活动 运营CRM：销售人员自动化，营销自动化，服务自动化 营销自动化：定时发送邮件，社交媒体上发送社交信息 服务自动化：客户通过电话，邮件，知识库，服务门户，常见问题解答 协作：整合第三方外部相关者，供应商，供应商和分销商，信息整合部门/分发信息 客户数据平台CDP 以客户为中心的关系管理CCRM 财务投资回报ROI 感知质量 关系，价值和品牌 客户利益的价值驱动因素：CRM为公司提供管理客户请求和内容的能力。呼叫中心软件能够将经理与各客户联系起来 GPS 供应链关系管理VRM]]></content>
      <categories>
        <category>CRM</category>
      </categories>
      <tags>
        <tag>CRM</tag>
        <tag>初始资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加一些小玩意]]></title>
    <url>%2F2019%2F06%2F04%2F2019-06-04-hexo%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%8E%A9%E6%84%8F%2F</url>
    <content type="text"><![CDATA[本文是一篇关于如何在hexo博客里添加一些小玩意的教程 Next的一些小玩意设置点击出现❤️型1.创建js文件 在/themes/next/source/js/src下新建文件clicklove.js，接着把下面的代码拷贝粘贴到clicklove.js文件中 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 2.修改_layout.swig 在\themes\next\layout下的_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 显示二次元动漫人物1.安装插件 进入hexo博客根目录执行以下命令安装插件 1npm install --save hexo-helper-live2d 2.安装动画模型 动画原型地址https://huaji8.top/post/live2d-plugin-2.0/ 动画原型下载模版 123456789101112131415161718live2d-widget-model-haru/02 live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 选择好对应的模型，使用npm install 模型的包名来安装，比如我选择的是live2d-widget-model-hibiki 1npm install live2d-widget-model-hibiki 3.配置 打开个人Hexo博客文件根目录下的 _config.yml 文件，在最后添加一下代码 1234567891011121314151617#二次元live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko #这个是你要修改的 display: position: right #在屏幕上的显示位置 width: 85 #显示宽度 height: 170 #显示高度 mobile: show: false #手机端是否显示 注意：当你换了动漫人物，发现在本地并没有展示出来的时候，或者明明设置了宽高时，不用慌，你可以hexo clean一下，再hexo g生成静态文件，hexo s启动本地服务看看，这样应该就行了。 4.卸载 当你不想要的时候，可以enable设置为false，也可以卸载 1npm uninstall hexo-helper-live2d]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>小玩意</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加分类和标签]]></title>
    <url>%2F2019%2F06%2F02%2F2019-06-01-Next%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[本文是一篇关于如何在Next主题下添加分类和标签的教程 如何在next主题下添加分类和标签添加分类页面1.新建页面 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 ==categories== 12$ cd your-hexo-site$ hexo new page categories 2.设置页面类型 编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下： 1234title: 分类date: 2019-06-1 12:00:04type: "categories"--- 3.修改菜单 在菜单中添加链接。编辑 ==主题配置文件== ， 添加 categories 到 menu 中，如下: 1234menu: home: / archives: /archives 分类: /categories 添加标签页面1.新建页面 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 ==tags== 12$ cd your-hexo-site$ hexo new page tags 2.设置页面类型 编辑刚新建的页面，将页面的 type 设置为 tags ，主题将自动为这个页面显示分类。页面内容如下： 1234title: 标签date: 2019-06-1 12:39:04type: "tags"--- 3.修改菜单 在菜单中添加链接。编辑 ==主题配置文件== ， 添加 tags 到 menu 中，如下: 1234menu: home: / archives: /archives 标签: /tags 创建模版在编写md文件时如果总是要填写上述步骤很麻烦，所以建立一个模板时最好的选择，这个模板就在\scaffolds\post.md 我使用的模板： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- title是文章标题 data是编写日期。这两个都会自动生成(如果使用命令行创建md文件的话) categories中填写分类 tags中填写标签 例如我使用命令行： 1$ hexo new "hexo在next主题下如何添加分类和标签" 就会在\source_posts目录下生成一个hexo在next主题下如何添加分类和标签的md文件，显示如下 123456789101112---title: hexo在next主题下如何添加分类和标签date: 2018-10-06 22:38:18categories:- 前端 - 搭建博客tags:- 搭建博客- 前端- next- 备忘--- 随便写点信息，刷新一下hexo，部署一下，在我们的博客上就会看到我们新写的文章了。]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>分类</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo insert images]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01-hexo-insert-images%2F</url>
    <content type="text"><![CDATA[本文是一篇关于Hexo如何生成本地图片的教程 hexo生成博文插入本地图片步骤把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 等待一小段时间后，再运行hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 （当然也可以自己手动建） 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 遇到问题遇到没能成功显示的问题，查看网页，结果是 &lt;img src=&quot;2017/02/26/2017-02-23-c/图片名.jpg&quot;&gt; 的形式，然后查看 hexo 的目录，发现路径是 /public/2017/02/26/c/a.jpg。 之前在 md 文件中引用时写作： ![你想输入的替代文字](xxxx/图片名.jpg) 改为： ![](a.jpg) 就可以了。 效果查看 这篇文章 的图片显示。 为什么看上面的效果，出错原因是 /public/2017/02/26/c/ 文件夹中没有生成保存图片的同名文件夹，图片直接被拷贝到这个文件夹下了。 突然想起从 jekyll 转移到 hexo 的时候更改过文章路径与标题解析方式… 不知道有没有关联。 hexo 修改文章路径产生的链接和两条属性相关。 permalink: :year/:month/:day/:title/ 链接格式 new_post_name: :title.md 解析标题方式 之前文章的命名方式都是 YYYY-MM-DD-title （jekyll 的文章格式），比如文件 2018-05-30-hexo-image.md 。 hexo 渲染时解析博文的标题为 2018-05-30-hexo-image 。 当如上设置 permalink 后，路径就是 http://hqweay.cn/2018/05/30/2018-05-30-hexo-image/ 这样。 时间出现了两次好诡异啊。 可以修改 permalink： ：title/ ，链接就直接用标题来区分。 效果是：http://hqweay.cn/2018-05-30-hexo-image/ 但是我想导入评论，链接最好和之前 jekyll 的一致。 于是就想办法改改后面。 hexo 提供了 new_post_name 。这条属性是定义 hexo 对文章标题的解析方式的。 默认为 new_post_name: :title.md 。 我们修改为 new_post_name: :year-:month-:day-:title.md 。 对比文件命名，很容易理解。 这样，hexo 就会把自动提取出文件的命名中的文章标题，而不是直接把文件的命名解析为标题。 路径就为： http://hqweay.cn/2018/05/30/hexo-image/]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>生成</tag>
        <tag>本地图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu Install Oracle]]></title>
    <url>%2F2019%2F05%2F30%2FUbuntu-Install-Oracle%2F</url>
    <content type="text"><![CDATA[Ubuntu 18.04 Docker 安装 Oracle Database 使用docker安装oracle登录docker1docker login 相应的输入注册的docker用户名和密码，如果没有注册，先去docker官网注册 https://hub.docker.com 下载oracle镜像拉取oracle镜像 1docker pull deepdiver/docker-oracle-xe-11g 运行oracle 1docker run -d -p 49160:22 -p 49161:1521 deepdiver/docker-oracle-xe-11g 查询oracle镜像是否已经存在 1docker ps 显示如下就说明镜像已经存在了 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScc6bc8d8aa17 deepdiver/docker-oracle-xe-11g "/bin/sh -c 'sed -i …" 16 seconds ago Up 11 seconds 8080/tcp, 0.0.0.0:49160-&gt;22/tcp, 0.0.0.0:49161-&gt;1521/tcp hardcore_engelbart 将容器的名称重新命名为oracle 1docker rename hardcore_engelbart oracle 进入oracle的容器 1docker exec -it oracle bash 进入oracle 1sqlplus /nolog 使用system进入oracle 1connect system 会提示输入密码，密码为：oracle 然后出现以下信息 12345ERROR:ORA-28002: the password will expire within 7 daysConnected. 这个密码只能适用7天，因此需要修改密码,退出oracle的system，在oracle容器里： 先给oracle权限 1su oracle 以sysdba的方式进入oracle 1sqlplus / as sysdba 修改密码时间权限 1alter profile default limit password_life_time unlimited; 查询修改后的密码配置情况 1select * from dba_profiles s where s.profile='DEFAULT' and resource_name='PASSWORD_LIFE_TIME'; 如果DEFAULT为unlimit就是配置成功了 远程登录方式1234567Connection Type:Basicport:49161Service Name:xeService Name的类型:SIDRole:DefaultUser name:systempassword:oracle Mac下载SQL*Plus和Basic默认Mac下已经下载了连接oracle的工具，我下载的是Navicat Premium 下载SQL*Plus和Basic链接： http://www.oracle.com/technetwork/topics/intel-macsoft-096467.html 下载内容： instantclient-basic-macos.x64–11.2.0.4.0.zipinstantclient-sqlplus-macos.x64–11.2.0.4.0.zip cd到下载内容所在的文件夹下 把下载好的文件放到~/Library/Caches/Homebrew下 12mv instantclient-basic-macos.x64-18.1.0.0.0.zip ~/Library/Caches/Homebrewmv instantclient-sqlplus-macos.x64-18.1.0.0.0.zip ~/Library/Caches/Homebrew 执行以下命令 123$ brew tap InstantClientTap/instantclient$ brew install instantclient-basic$ brew install instantclient-sqlplus 在运行brew install instantclient-basic和brew install instantclient-sqlplus命令时，也许会出现错误提示信息，要求对instantclient-basic-macos.x64–11.2.0.4.0.zip和instantclient-sqlplus-macos.x64–11.2.0.4.0.zip改名并移动到~/Library/Caches/Homebrew/Download下。复制要修改的名称改名并复制就可 例如： 123To this location (a specific filename in homebrew cache directory): /Users/wanghui/Library/Caches/Homebrew/downloads/1ace9ca784e431112e837a769fc89eae38ad1489165c38aa698139d25d8fd96b--instantclient-basic-macos.x64-18.1.0.0.0.zip 进入~/Library/Caches/Homebrew，将instantclient-basic-macos.x64–11.2.0.4.0.zip修改为1ace9ca784e431112e837a769fc89eae38ad1489165c38aa698139d25d8fd96b–instantclient-basic-macos.x64-18.1.0.0.0.zip，然后移动到~/Library/Caches/Homebrew/downloads 配置Navicat PremiumNavicat Premium –&gt; Preferences –&gt; Environment 默认的安装路径 /usr/local/Cellar/instantclient-sqlplus/18.1.0.0.0 将其填入 这个是我本人的 个人oracle账号： Connect database with following setting: hostname: localhost port: 1521 sid: EE service name: EE.oracle.docker username: system password: oracle To connect using sqlplus: sqlplus system/oracle@//localhost:1521/EE.oracle.docker Password for SYS &amp; SYSTEM: oracle]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>install</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04 VM]]></title>
    <url>%2F2019%2F05%2F28%2FUbuntu18-04-VM%2F</url>
    <content type="text"><![CDATA[配置Ubuntu 18.04基础镜像 在Windows上安装Ubuntu18.04虚拟机下载Ubuntu18.04的镜像下载链接https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ 下载的版本ubuntu-18.04.2-live-server-amd64.iso 在VMware里安装虚拟机安装过程省略,这里主要讲解开启虚拟机后的一些设置 修改镜像地址,改成阿里云的.https://mirrors.aliyun.com/ubuntu/ 选择：Use An Entire Disk And Set Up LVM 选择安装openSSH,如果这个没有安装,进入到系统后,要执行以下命令安装$ apt install openssh-server 其它的都不用配置,直接done 开启虚拟机root用户权限设置root的密码并开启root权限 12$ sudo passwd$ su root 修改root的权限配置文件vi /etc/ssh/sshd_config 修改如下 重启ssh服务service ssh restart 在Xshell里使用root用户登录 设置静态ip和DNS编辑配置文件 /etc/netplan/50-cloud-init.yaml 12345678910network: ethernets: ens33: addresses: [192.168.10.129/24] gateway4: 192.168.10.2 nameservers: addresses: - 114.114.114.114 - 114.114.115.115 version: 2 使其生效netplan apply 配置文件里的ens33是和ip a里得到的一致 注意这个配置文件的格式,一个空格都可能导致配置出错 启动servicesystemctl start systemd-resolved.service 设置为开机自启动systemctl enable systemd-resolved.service 重启reboot 试验网络ping www.baidu.com 检查ip地址是否是自己设置的静态ipip a 做个快照鼠标右键虚拟机--&gt;快照--&gt;拍摄快照 交换空间的设置关闭交换空间swapoff -a 避免开机启动交换空间vi /etc/fstab修饰掉带swap的一行 关闭防火墙ufw disable 关机shotdown -h now 开机做个快照鼠标右键虚拟机--&gt;快照--&gt;拍摄快照 安装docker使用APT安装docker,方法来源: https://funtl.com/zh/service-mesh-kubernetes/%E5%AE%89%E8%A3%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87.html#%E4%BD%BF%E7%94%A8-apt-%E5%AE%89%E8%A3%85-docker 123456789101112# 更新软件源sudo apt-get update# 安装所需依赖sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common# 安装 GPG 证书curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 新增软件源信息sudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"# 再次更新软件源sudo apt-get -y update# 安装 Docker CE 版sudo apt-get -y install docker-ce 验证12345678910111213141516171819root@yytubuntu:~# docker versionClient: Version: 18.09.6 API version: 1.39 Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 02:35:57 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.6 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 01:59:36 2019 OS/Arch: linux/amd64 Experimental: false 配置加速方法来源地址: https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors?accounttraceid=9b8e4567-a62c-4723-95e0-6fcb5b44c87f 逐条输入以下命令 1234567891011sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://veoukc4z.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 查看是否配置成功 输入docker info,出现以下信息就是配置成功了 12Registry Mirrors:https://veoukc4z.mirror.aliyuncs.com/ 使用pip安装docker-compose获取get-pip.py方法来源,安装这个是为了安装pip: https://pip.pypa.io/en/stable/installing/ 获取get-pip.py命令 1curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py 要安装get-pip.py需要python,get-pip.py不能和本机自带的python相和谐,所以要自己安装python 使用ppa安装python 安装ppa sudo add-apt-repository ppa:deadsnakes/ppa 安装python apt install python3.7 安装get-pip.py python3.7 get-pip.py 更改pip的镜像源 更改方式的地址来源: https://mirrors.tuna.tsinghua.edu.cn/help/pypi 使用临时镜像升级pip,提高网速 1$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U 升级pip到最新版本后进行配置 12$ pip install pip -U$ pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 安装docker-compose $ pip install -U docker-compose 删除get-pip.py 12$ ls$ rm -fr get-pip.py 关机 $ reboot 开机做个快照 克隆克隆不是新创建一个虚拟机,而是在原有虚拟机上做改变,不会影响最初的base虚拟机 鼠标右键--&gt;管理--&gt;克隆 导出OVF格式文件导出的文件删除了DVD驱动,导入到新的VMware后要添加DVD驱动和镜像]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>install</tag>
        <tag>ubuntu18.04</tag>
        <tag>VM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-09_体系结构设计]]></title>
    <url>%2F2019%2F05%2F25%2F2019-05-25-09-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文是一篇关于软件体系结构的文章 体系结构设计软件体系结构什么是体系结构程序或计算系统的软件体系结构是指系统的一个或者多个结构，它包括软件构件、构件的外部可见属性以及它们之间的相互关系 体系结构并非可运行的软件，确切说，它是一种表达，能够： 1.对设计在满足既定需求方面的有效性进行分析 2.在设计变更相对容易的阶段，考虑体系结构可能的选择方案 3.降低与软件构造相关的风险 “体系结构”和”设计”的区别:类与对象之间的区别 例如：使用Java和.NET对同一个项目进行设计，其设计方法是不一样的，但其体系结构是一样的。只有对一个项目的体系结构想的越明白，设计就越容易 体系结构为什么重要 软件体系结构的表示有助于对计算机系统开发感兴趣的各方(利益相关者)开展交流 体系结构突出了早期的设计决策，这些决策对随后所有的软件工程工作有深远的影响，同时对系统作为一个可运行实体的最后成功有重要作用 体系结构“构建了一个相对小的、易于理解的模型，该模型描述了系统如何构成以及其构件如何一起工作” 体系结构描述不同利益相关者会从不同的角度理解体系结构，它是有不同的关注点驱动的，所以，体系结构描述实际上是一组体现系统不同视图的工作产品。体系结构应当考虑到每个利益相关者想要的东西 体系结构决策体系结构决策描述模版 1234567891011121314每个主要的体系结构决策可以被记录在案，以便以后评审，评审由想要理解已提出的体系结构描述的利益相关者进行。设计问题：描述将要解决的体系结构设计问题解决方案：陈述所选择的解决设计问题的方法分类：指定问题和解决方案陈述的分类(例如，数据设计、内容结构、构件结构、集成、介绍)假设：指出任何有助于指定决策的假设约束：指定任何有助于指定决策的环境约束(例如，技术标准、可用的模版、项目相关问题)候选方案：简要描述所考虑的体系结构设计候选方案，并描述为什么要摒弃这些方案争论：陈述你为什么选择了这种解决方案而不是其他的候选方案意义：指出制定决策对设计的影响。选择方案如何影响其他的体系结构设计问题？解决方案会在某种程度上约束设计吗？相关策略：其他记录的决策和该决策有什么相关性？相关关注点：其他需求和该决策有什么相关性？工作产品：指出体系结构描述中，决策会在哪里体现出来注释：参考可用来制定决策的其他团队的备忘录或文档 体系结构类型体系结构类型：如今社会软件设计常见的 12345678910111213141516171819人工智能商业和非盈利的通信内容制作设备娱乐于运动金融游戏行政管理工业法律医疗军事操作系统平台科学工具运输实用程序 以上每种类别在如今社会中都已经形成了相应的体系结构，每种类别的具体分类要采用更具体的体系结构。例如：游戏，也分塔防游戏，益智游戏，战略游戏，枪战游戏 体系结构风格由相关的体系结构风格就能理解系统的整体性质。这就像，我要盖个“茅草屋”，你在脑子里就能想到“茅草屋”的大概样子 5种典型的基本体系结构 123456789功能结构：构件表示功能或实体，连接件表示接口。特性描述构件的特性和接口的组织实现结构：购进可以是包、类、对象、过程、函数、方法等所有在不同抽象层上打包的功能。连接件包括传递数据和控制、共享数据、“使用”以及“是一个实例”等能力。特性关注于结构实现时的质量特性(例如：可维护性、可重用性)并发结构：构件表示“并发单元”(并发任务或线程)。“关系”(连接件)包括同步于、优先级高于、发送数据到、运行必须有、运行不能有。与结构相关的特性包括优先级、抢先占有以及执行时间物理结构：类似于设计开发中的部署模型。构件是物理硬件，软件驻留在硬件上。连接件是硬件构件之间的接口。特性用来描述容量、带宽、性能和其他属性开发结构：该结构定义构件、工作产品以及软件工程过程中所需的其他信息源。连接件表示工作产品之间的关系。特性标识每项的特征 体系结构风格的简单分类几种常见的体系结构 以数据为中心的体系结构：核心是数据库 数据流体系结构 调用和返回体系结构 主程序/子程序体系结构：主程序调用一组构件，这些构件又调用其他构件 远程过程调用体系结构：主程序/子程序体系结构的构件分布在网络中的多台计算机上 面向对象体系结构 层次体系结构：参考MVC设计模式考虑 体系结构模式12章再讲 组织和求精体系结构设计的评估标准 控制： 1234567在体系结构中如何管理控制？是否存在清晰的控制层次？如果存在，构件在控制层次中有什么作用？构件如何在系统中传递控制？构件间如何共享控制？控制的拓扑结构如何？控制是否同步或者构件操作是否异步？ 数据 1234567构件间如何进行数据通信？数据流是否是连续地传递给系统，或数据对象是否是零散地传递给系统？数据传递的模式是什么(即，数据是从一个构件传递到另一个构件，还是数据被系统中的构件全局共享)？是否存在数据构件(如黑板或中心数据库)？如果存在，它们的作用是什么？功能构件如何和数据构件交互？数据构件是被动的还是主动的(即数据构件是否主动地和系统的其他构件交互)？数据和控制如何在系统中交互？ 体系结构设计系统环境的表示体系结构环境图的一般结构 由图所示，与目标系统(为该系统所开发的体系结构设计)交互的系统可以表示为： 上级系统—-这些系统把目标系统作为某些高层处理方案的一部分 下级系统—-这些系统被目标系统使用，并为完成目标系统的功能提供必要的数据和处理 同级系统—-这些系统在对等的基础上相互作用(即信息或者同级系统和目标系统产生，或者被目标系统和同级系统使用) 参与者——通过产生和消耗必要处理所需的信息，实现与目标系统交互的实体(人，设备) 每个外部实体都通过某一个接口(带阴影的小矩形)与目标系统进行通信 定义原型原型是表示核心抽象的类或模式 原型包括：结点、探测器、指示器、控制器 将体系结构精华为构件一个将完整体系结构精华为构件的实例 其中的每一个方框都是一个构件 描述系统实例将上文中的完整体系结构再进一步精华 1234567体系结构设计 目的：体系结构设计工具通过描述构件接口、依赖与联系以及交互作用来建立整体软件结构模型 机制：工具采用的机制多种多样。在大多数情况下，体系结构的设计能力是分析和设计建模自动化工具的一部分功能 代表性工具： Adalon ObjectiF Rational Rose 评估可选的体系结构设计体系结构权衡分析方法目的：验证设计的体系结构是否能用 1.收集场景：开发一组用例，从用户角度描述系统 2.引出需求、约束和环境描述：确保所有利益相关者问题都被处理 3.描述那些已经被选择用于解决场景和需求的体系结构风格/模式：采用以下一种描述 a.模块视图：分析带有构件的工作任务以及信息隐蔽获得的程度 b.过程视图：分析系统性能 c.数据流视图：分析体系结构满足功能需求的程度 4.通过单独地考虑每个属性来评估质量属性：包括可靠性、性能、安全性、可维护性、灵活性、可测试性、可移植性、可复用性和互操作性 5.针对特定的体系结构风格，确定质量属性对各种体系结构属性的敏感性：通过体系结构变更测试，受变更大的就是敏感点 6.找第5步的敏感点，然后做成候选体系结构 体系结构复杂性体系结构的复杂性体现在体系结构中构件间的依赖关系，包括 1.共享依赖：存在与使用相同资源的消费者或相同消费者生产的生产者之间的依赖关系 2.流依赖：生产者和消费者之间的依赖 3.约束依赖：一组活动间相关控制流上的约束 体系结构描述语言体系结构描述语言(architectural description language,ADL)提供了一种描述软件体系结构的语义和语法 UML没有ADL完成，以下是5个ADL 12345Rapide:UniConAesopWrightAcme 使用数据流进行体系结构映射从DFD到软件体系结构的便捷的转化，转化由下述6个步骤的一部分完成 1.建立信息流的类型 2.标注流的边界 3.将DFD映射到程序结构 4.定义控制层级 5.使用设计度量和启发式精华产生的结构 6.求精华细化体系结构描述 变换映射将具有变换流特征的DFD映射为某个特定的体系结构风格，图示为SafeHome的安全例子 步骤1：评审基本系统模型 DFD图从0层到1层的转换 步骤2：评审和精华软件的数据流图 DFD图从1层到2层到转换 步骤3：确定DFD是否含有变换流或事物流特征 DFD图从2层到3层的转换，这次转换要搞清楚数据流的输入和输出 步骤4：通过确定输入和输出流的边界，分离出变换中心 输入是信息从外部形式转内部形式，输出是信息从内部形式转外部形式流边界是指在流从外部转内部(或从内部转外部)的边界处 步骤5:完成“第一级分解” 以步骤4的边界处为界限进行第一级的分解 步骤6:完成“第二级分解” 将每个变换(泡泡)映射到体系结构中的相应模块，从变换中心的边界开始，沿输入路径和输出路径向外，将变换依次映射到软件结构的从属层。一般是一对一映射，有时会有多个泡泡合并为一个构件，或者一个泡泡分解为多个构件的情况。这步结束，就得到了第一次的迭代体系结构 步骤7:使用提高软件质量的设计启发式方法，精华第一次迭代得到的体系结构 精化第一次迭代得到的体系结构。对构件进行“分解”和“结合” 最终逐渐精华的完善版 构件的和并和消除 精华体系结构设计不能工作的“优化设计”是值得怀疑的 设计求精应在满足有效模块要求的前提下尽量减少构件的数量，在充分满足信息需求的前提下尽量减少复杂的数据结构]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-08_设计概念]]></title>
    <url>%2F2019%2F05%2F24%2F2019-05-23-08_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文是一篇关于软件设计概念的文章 设计概念软件工程中的设计一旦对软件需求进行分析和建模，软件设计就开始了 软件设计是建模活动的最后一个软件工程活动，接下来就是构造阶段。 设计一定要保证—–质量 设计过程设计过程：迭代 软件质量指导原则和属性设计的质量指导原则 1.设计应该有的结构 a.已经使用可识别的体系结构风格或模式创建 b.由展示出良好设计特征的构件构成 c.能够以演化的方式实现，从而便于实现和测试 2.设计应该模块化 3.设计应该包含数据、体系结构、接口和构件的清晰表示 4.设计应导出数据结构，这些数据结构适用于要实现的类，并从可识别的数据模式提取 5.设计应导出显示独立功能特征的构件 6.设计应导出接口，这些接口降低了构件之间以及与外部环境连接的复杂性 7.设计的导出应根据软件需求分析过程中获取的信息采用可重复的方法进行 8.应使用能够有效传达其意义的表示法来表达设计 质量属性FURPS 1.功能性(functionality) 2.易用性(usability) 3.可靠性(reliability) 4.性能(performance) 5.可支持性(supportability) 软件设计的演化无论软件设计如何演化，都有一些共同的特征 1.将需求模型转化为设计表示的方法 2.表示功能性构件及它们之间接口的表示法 3.精华和分割的启发式方法 4.质量评估的指导原则 1234567891011121314151617181920212223242526通用设计任务集 1.检查信息域模型，并为数据对象及其属性设计恰当的数据结构 2.使用分析模型，选择一种使用于软件的体系结构风格 3.将分析模型分割为若干个设计子系统，并在体系结构内分配这些子系统： 确保每个子系统是功能内聚的。 设计子系统接口。 为每个子系统分配分析类或功能。 4.创建一系列的设计类或构件： 将每个分析类描述转化为设计类 根据设计标准检查每个设计类，考虑继承问题 定义与每个设计类相关的方法和消息 评估设计类或子系统，并为这些类或子系统选择设计模式 评审设计类，并在需要时修改 5.设计外部系统或设备所需要的所有接口 6.设计用户接口： 评审任务分析的结果 基于用户场景详细说明活动序列 创建接口的行为模型 定义接口对象、控制机制 评审接口设计，并根据需要进行修改 7.进行构件级设计 在相对较低的抽象层次上详细地说明所有算法 精华每个构件的接口 定义构件级的数据结构 评审每个构件并修正所有已发现的错误 8.开发部署模型 设计概念设计概念提供应用更加复杂设计方法的基础，每种方法可以回答的问题： 使用什么标准将软件分割为独立的构件 功能和数据结构细节如何从软件的概念表示中分离出来 定义软件设计技术质量的统一标准是什么 抽象过程抽象 具有明确和有限的指令序列，只体现功能，不显示细节，例如“开门”，“开”所隐藏的一系列过程并不体现出来 数据抽象 描述数据对象的冠名数据集合。例如“开门”，“开”是动词，不会携带数据，但“门”是携带数据的，例如“门”的类型，转动方向，门的大小等 体系结构简单解释 可以把体系结构理解为模块的结构或组织，以及模块交互的形式和所用数据的结构 广泛解释 主要系统元素及其交互 ？？？？？？？ 模式解决重复方案 模式是否适用于当前的工作 模式是否能够复用 模式是否能够用于指导开发一个类似的、但是功能或结构不同的模式 关注点分离将复杂问题分解为可以独立解决和优化的若干块，分而治之 模块化模块化的划分不能无限制的划分，划分太多就会集合麻烦，划分太少就会功能复杂 信息隐蔽每个模块对其它所有模块都隐藏自己的设计决策。模块应该规定并设计成为在模块中包含的信息(算法和数据)不被不需要这些信息的其它模块访问 功能独立就是做到模块的高内聚、低耦合 求精逐步求精：自顶向下的设计策略，一个逐渐细化的过程 方面解决问题：需求B必须在需求A满足的情况下才能进行 重构一种简化构件的设计，其实就是重新组装 面向对象的设计概念设计中遵循面向对象思想 设计类 1.通过提供设计细节精华分析类，这些设计细节将促成类的实现 2.实现支持业务解决方案的软件基础设施 5种不同类型的设计类 1.用户接口类：人-机交互 2.业务域类：业务的属性和服务 3.过程类：实现完整的管理业务所必须的低层业务抽象 4.持久类：数据库 5.系统类：软件管理和控制功能 类应当有的特性 1.完整性和充分性：完整的属性和方法 2.原始性：专注于关注实现类的某一个服务，一旦服务被实现，就不在提供完成同一事情的另外一个方法 3.高内聚性 4.低耦合性 设计模型设计模型和分析模型 数据设计元素数据模型到数据库的转换，这个非常重要，但抽象程度更高 体系结构设计元素软件的体系结构设计等效于房屋的平面图 体系结构模型的来源： 关于将要构建的软件的应用域信息 特定的需要模型元素，如数据流图或分析类、现有问题中它们的关系和协作 体系结构风格和模式的可获得性 接口设计元素软件的接口设计相当于一组房屋的门、窗和外部设施的详细绘图 接口设计有3个重要的元素 1.用户界面 2.和其它系统、设备、网络和其它信息生成者或使用者的外部接口 3.各种设计构件之间的内部接口 构件级设计元素构件级设计相当于一个房屋中每个房间的一组详图。这些图描绘了每个房间内的布线和管道、电器插座和墙上开关、水龙头、水池、淋浴、浴盆、下水道 部署级设计元素部署级设计元素指明软件功能和子系统将如何在支持软件的物理计算环境内分布]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-07_需求建模：流程、行为、模式和Web应用]]></title>
    <url>%2F2019%2F05%2F22%2F2019-05-22-07-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文是一篇关于软件需求建模的文章 需求建模：流程、行为、模式和Web应用需求建模策略结构化分析： 考虑数据和处理的分析建模方法，数据可作为独立实体转换。数据对象模型的方式定义了它们的属性和关系，表明当数据对象通过系统时如何转换数据。 面向对象分析： 专注于定义类以及影响客户需求的类之间的协作方式 面向数建模数据流图(DFD) 输入-处理-输出，流入软件的数据对象，经由处理元素变换，最后以结果数据对象的形式流出软件。 表达方式： 1234带标记的箭头表示数据或控制对象圆圈(泡泡)表示转换，0层是系统，其它层是动名词结合名词是外部实体，用方框表示数据存储，双横线表示 分层：0层，1层，2层…… 创建数据流模型数据流图创建方式： 1.第0层的数据流图应将软件或者系统描述成一个泡泡 2.应仔细标记主要的输入和输出 3.通过把选定的处理、数据对象和数据存储分离为下一层表示而开始精化过程 4.应使用有意义的名称标记所有的箭头和泡泡 5.当从一个层转到另一个层时要保持信息流连续性 6.一次精化一个泡泡 原则： 逐渐精华泡泡 保持信息流的连续性 创建控制流模型事件驱动的问题需要使用控制流建模 控制规格说明Control Specification CSPEC 状态图，下章节会重点讲解 处理规格说明Process Specification,PSPEC 生成行为模型目的：将静态元素转换为系统或产品的动态行为 生成模型的步骤 1.评估所有的用例，以保证安全理解系统内的交互顺序 2.识别驱动交互顺序的事件，并理解这些事件如何与特定的对象相互关联 3.为每个用例生成序列 4.创建系统状态图 5.评审行为模型以验证准确性和一致性 识别用例事件用例表现了涉及参与者和系统的活动顺序。一般而言，只要系统和参与者之间交换了信息就发生事件。事件可以理解为一个动作或行为，例如，输入密码是个事件，商品加入购物车是个事件，吃饭是个事件。一旦找到了事件，要做的是将其分配到所涉及的对象。对象负责生成事件 状态表现行为建模必须考虑的两种不同的状态描述 1.系统执行其功能时每个类的状态 2.系统执行其功能时从外部观察到的系统状态 类状态具有被动和主动两种特征 1.被动状态只是某个对象所有属性的当前状态 2.一个对象的主动状态指的是对象进行持续变换或处理时的当前状态 以下讨论两种不同的行为表现形式，第一种显示一个类如何改变基于外部事件的状态，第二种以事件函数的形式显示软件的行为 分析类的状态图。UML状态图就是一种行为模型，该图为每个类呈现了主动状态和导致这些主动状态变化的事件 顺序图。该图表明事件如何引发从一个对象到一个对象的转移。一旦通过检查用例确认了事件，建模人员就创建了一个顺序图，即用时间函数表现如何引发事件从一个对象流到另一个对象 UML建模工具 12345678ArgoUML `argouml.tigris.org`Enterprise Architect `www.sparxsystems.com.au`PowerDesigner `www.sybase.com`Rational Rose `www.ibm.com/software/retional`System Architect `www.popkin.com`UML Studio `www.pragsoft.com`Visio `www.mocrosoft.com`Visual UML `www.visualuml.com` 需求建模的模式发现分析模式需求模型由各种元素组成 基于场景(用例) 基于数据(数据模型) 基于类 基于流和行为 需求模型中最基本的元素是用例。语义分析模式(semantic analysis pattern,SAP)是描述了一小套连贯用例，这些用例一起描述了通用应用的基础。 需求模式举例不再分析 Web应用系统的需求建模如何分析Web应用需求建模的重视程度依据以下因素 1.Web应用的规模和复杂性的增长 2.相关利益者的人数(识别需求冲突) 3.Web应用团队的人数 4.一起工作以前该Web应用团队成员的级别 5.组织成功的程度直接依赖Web应用的成功 需求建模的输入需求建模输入的表现形式 自然语言描述 概要大纲 草图 其它非正式形式 需求建模的输出5种主要的模型类型 内容模型：包括文本、图表和图像、视频和音频数据 交互模式：描述了用户与Web应用系统采用了哪种交互方式 功能模式：定义了将用于Web应用系统内容并描述其他处理功能的操作，这些处理功能不依赖于内容却是最终用户所必需的 导航模式：为Web应用系统定义所有导航策略 配置模型：描述Web应用系统所在的环境和基础设施 Web应用系统内容建模内容对象是呈现给最终用户具有汇聚信息的所有条目 数据树分析内容对象图示： Web应用系统的交互模型交互模型可以由下面的一种或多种组成： 1.用例 2.顺序图 3.状态图 4.用户界面原型 一般使用用例就行，对于复杂的情况需要使用顺序图和状态图，甚至用户界面原型 Web应用系统的功能模型功能模型描述Web应用系统的两个处理元素，每个处理元素代表抽象过程的不同层次 1.用户可观察到的功能有Web应用系统传递给最终用户的 2.分析类中的操作实现与类相关的行为 在功能模型创建的过程中，如果存在着潜在的复杂的行为，可以使用活动图进行分析 Web应用系统的配置模型配置较为复杂时，使用UML部署图 导航建模具体情况具体分析]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>需求建模</tag>
        <tag>流程</tag>
        <tag>行为</tag>
        <tag>模式</tag>
        <tag>Web应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作Windows操作系统工具盘]]></title>
    <url>%2F2019%2F05%2F22%2F2019-05-21-%E5%88%B6%E4%BD%9CWindows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7%E7%9B%98%2F</url>
    <content type="text"><![CDATA[本文是一篇关于制作Windows工具盘的文章 Windows操作系统工具盘制作流程下载Windows镜像下载地址 https://msdn.itellyou.cn/ 路径 选择操作系统，然后选择要下载的Windows镜像，我这里选择的是W10 1089Version 4月更新的，然后选择企业版的，比较稳定 下载 复制ed2k的下载连接，然后在下载工具里下载，例如使用迅雷下载 导入工具盘我这里使用rufus导入工具盘，因为rufus操作简单，没其它原因，就喜欢它这点,ubuntu也能使用这个工具 下载rufus，这里提供两种方式 1.网站下载：http://rufus.ie/ 2.命令行下载 123下载之前要要安装好git，openSSH，scoop$ scoop bucket add extras$ scoop install rufus 制作工具盘，相信我，它简单的像个咦…… 插入工具盘，打开rufus，rufus一般会自动检索到你的U盘，你只需要在Boot selection里选择你下载好的镜像，然后点击START 好了，你没有看错，就只需要选择一个镜像路径就行了，于是工具盘制作完成，接下来愉快的安装操作系统去吧]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>工具盘</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vagrant-自动部署虚拟机、JDK、Mysql]]></title>
    <url>%2F2019%2F05%2F22%2F2019-05-21_Vagrant%2F</url>
    <content type="text"><![CDATA[本文是一篇关于使用vagrant自动部署虚拟机、JDK、Mysql 使用vagrant自动部署虚拟机、JDK、Mysql这里主要介绍Vagrantfile的配置文件 Vagrantfile文件配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- mode: ruby -*-# vi: set ft=ruby :# All Vagrant configuration is done below. The "2" in Vagrant.configure# configures the configuration version (we support older styles for# backwards compatibility). Please don't change it unless you know what# you're doing.Vagrant.configure("2") do |config| # The most common configuration options are documented and commented below. # For a complete reference, please see the online documentation at # https://docs.vagrantup.com. # Every Vagrant development environment requires a box. You can search for # boxes at https://vagrantcloud.com/search. #config.vm.box = "centos7" #config.vm.hostname = "host1" # Disable automatic box update checking. If you disable this, then # boxes will only be checked for updates when the user runs # `vagrant box outdated`. This is not recommended. # config.vm.box_check_update = false # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine. In the example below, # accessing "localhost:8080" will access port 80 on the guest machine. # NOTE: This will enable public access to the opened port # config.vm.network "forwarded_port", guest: 80, host: 8080 # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine and only allow access # via 127.0.0.1 to disable public access # config.vm.network "forwarded_port", guest: 80, host: 8080, host_ip: "127.0.0.1" # Create a private network, which allows host-only access to the machine # using a specific IP. #config.vm.network "private_network", ip: "192.168.31.10" # Create a public network, which generally matched to bridged network. # Bridged networks make the machine appear as another physical device on # your network. # config.vm.network "public_network" # Share an additional folder to the guest VM. The first argument is # the path on the host to the actual folder. The second argument is # the path on the guest to mount the folder. And the optional third # argument is a set of non-required options. # config.vm.synced_folder "../data", "/vagrant_data" # Provider-specific configuration so you can fine-tune various # backing providers for Vagrant. These expose provider-specific options. # Example for VirtualBox: # # config.vm.provider "virtualbox" do |vb| # # Display the VirtualBox GUI when booting the machine # vb.gui = true # # # Customize the amount of memory on the VM: # vb.memory = "1024" # end # # View the documentation for the provider you are using for more # information on available options. # Enable provisioning with a shell script. Additional provisioners such as # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the # documentation for more information about their specific syntax and use. # 定义应用服务器 config.vm.define :web do |web| web.vm.provider "virtualbox" do |v| v.customize ["modifyvm", :id, "--name", "web", "--memory", "512"] end web.vm.box = "centos7" web.vm.hostname = "web" web.vm.network :private_network, ip: "10.0.2.19" config.vm.provision "shell", inline: &lt;&lt;-SHELLend JDK的shell脚本配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/bin/bash echo "================= START install-jdk.sh $(date +"%r") =================" echo " " echo "BEGIN installing JDK" ################################################################# ## JDK Installation ################################################################# JDK_VERSION="8u51" JDK_LONGVERSION="1.8.0_51" JDK_FILE="jdk-$JDK_VERSION-linux-x64.gz" JDK_FORCE=0 # Check if we have this JDK installed if [ ! -d "/usr/lib/jvm/jdk1.8.0_51" ] || [ $JDK_FORCE -eq 1 ]; then # Don't download if we've already got it locally if [ ! -f "/vagrant/artifacts/$JDK_FILE" ]; then echo "... Downloading JDK: $JDK_VERSION, standby ..." wget -O /vagrant/artifacts/$JDK_FILE http://downloads.ortussolutions.com/oracle/jdk/$JDK_VERSION/$JDK_FILE &amp;&gt;&gt; /vagrant/log/install.sh fi # Install JDK sudo gunzip -c /vagrant/artifacts/$JDK_FILE &gt; jdk-$JDK_VERSION-linux-x64.tar sudo tar -xvf jdk-$JDK_VERSION-linux-x64.tar &amp;&gt;&gt; /vagrant/log/install.txt #sudo gzip /vagrant/artifacts/jdk-$JDK_VERSION-linux-x64.tar &amp;&gt;&gt; /vagrant/log/install.sh # Move to install directory echo "Moving JDK to installation directory at /usr/lib/jvm/jdk$JDK_LONGVERSION" sudo mkdir -p /usr/lib/jvm/jdk$JDK_LONGVERSION sudo mv jdk$JDK_LONGVERSION/* /usr/lib/jvm/jdk$JDK_LONGVERSION/ echo "Linking JDK to 'current' JDK" cd /usr/lib/jvm sudo ln -s /usr/lib/jvm/jdk$JDK_LONGVERSION/ current sudo update-alternatives --install "/usr/bin/java" "java" "/usr/lib/jvm/jdk$JDK_LONGVERSION/bin/java" 1 sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/lib/jvm/jdk$JDK_LONGVERSION/bin/javac" 1 sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/lib/jvm/jdk$JDK_LONGVERSION/bin/javaws" 1 #sudo update-alternatives --config java echo "Updated java locations successfully" else echo "JDK is already installed, skipping" fi # Move in environment sudo /bin/cp -f /vagrant/configs/.bash_profile /etc/environment echo "... END installing JDK." echo " " echo "================= FINISH install-jdk.sh $(date +"%r") =================" echo " " SHELL end Mysql的脚本配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 定义DB服务器config.vm.define :db do |db| db.vm.provider "virtualbox" do |v| v.customize ["modifyvm", :id, "--name", "db", "--memory", "512"] end db.vm.box = "mysqlVM" db.vm.hostname = "db" db.vm.network :private_network, ip: "10.0.2.20" config.vm.provision "shell", inline: &lt;&lt;-SHELL #!/bin/bash echo "-----------update system--------" #sudo yum -y update # y y echo "-------install wget---------" sudo yum -y install wget &amp;&gt;&gt; /vagrant/log/install.sh # y echo "------install mysql--------" wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm &amp;&gt;&gt; /vagrant/log/install.sh sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm sudo yum -y update &amp;&gt;&gt; /vagrant/log/install.sh echo "------search expect-------" rpm -qa | grep expect echo "--------install expect-------" sudo yum -y install expect &amp;&gt;&gt; /vagrant/log/install.sh # which expect ---&gt;/usr/bin/expect echo "-------install mysql-server-------" sudo yum -y install mysql-server &amp;&gt;&gt; /vagrant/log/install.sh sudo systemctl start mysqld #sudo mysql_secure_installation #1.输入当前密码：enter #sudo grep 'temporary password' /var/log/mysqld.log可以查询到。一般密码为空，按enter就行 #2.是否更改密码：y or enter #3.新密码：123456 #4.再此输入密码：123456 #5.删除匿名用户：y #6.禁止远程登陆：n #7.删除测试数据库：y or enter #8.是否重新加载权限表：y or enter echo "------------config mysql----------" set timeout 100 set firstpassword set newpassword 123456 expect&lt;&lt;-END spawn sudo mysql_secure_installation expect "enter for none:" send "$firstpassword\n" expect "Y/n" send "\n" expect "New password" send "$newpassword\n" expect "Re-enter new password:" send "$newpassword\n" expect "Y/n" send "\n" expect "Y/n" send "n\n" expect "Y/n" send "\n" expect "Y/n" send "\n" expect eof exit END SHELLend]]></content>
      <categories>
        <category>Vargrant</category>
      </categories>
      <tags>
        <tag>自动部署</tag>
        <tag>虚拟机</tag>
        <tag>JDK</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-06_需求建模：场景、信息、与类分析]]></title>
    <url>%2F2019%2F05%2F16%2F2019-05-16-06-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文是一篇关于需求建模的文章 需求建模：场景、信息、与类分析需求分析需求建模： 1.场景建模 2.数据建模 3.面向类的模型 4.面向流程的模型 5.行为模型 总体目标和原理需求建模必须实现3个主要目标： 1.描述客户需要什么 2.为软件设计奠定基础 3.定义在软件完成后可以被确认的一组需求 分析的经验原则模型的经验原则 1.模型应关注在问题域或业务域内可见的需求，不要陷入细节 2.每个元素都应该增加对软件需求的整体理解，以及对信息域、功能和系统行为的深入理解 3.基础结构和其它非功能的模型应推延到设计阶段再考虑 4.最小化整个系统内的关联 5.确认需求模型为整个利益相关者都带来价值 6.尽可能保持模型简洁 域分析域分析师：发现和定义可复用的分析模式，分析类和相关的信息 建立模型的方法结构化分析 将数据对象抽取为一个Model，由该Model来对数据结果进行分析 面向对象的分析 定义类和影响客户需求的类之间的协作关系 目的： 不管采用什么分析方法，我们最终都是为了为利益相关者提供最好的软件需求模型和过渡到软件设计的最有效方法。 需求模型的元素： 基于场景的建模新建初始用例开发用例问题： 1.编写什么？ 2.写多少？ 3.编写说明应该多详细？ 4.如何组织说明？ 1234567编写：1.起始和导出2.定义问题范围3.说明整体的运行目标4.建立优先级顺序5.概述所有已知的功能需求6.描述系统将处理的信息 对用例的分析可以采用两种形式，一种是模拟利益相关者来陈述用例故事，另外一种是以列表的形式逐条列出执行的步骤。 细化初始用例细化问题： 1.在这一状态点上，参与者能进行一些其它的动作吗？ 2.在这一状态点上，参与者有没有可能遇到一些错误的条件？如果有可能，这些错误会是什么？ 3.在这一状态点上，参与者有没有可能遇到一些其他的行为？是什么？ 还应该考虑的问题： 1.应答失败，如用户是等待一个应答，但应答超时了 2.性能差，如页面渲染速度贼慢 如何解决： 看下一小节，编写正规的用例 编写正规的用例干货：规范的用例模版 123456789101112131415161718192021222324252627282930313233用例：购买零食迭代：2，最新更新记录：hui XXXX年YY月RR日主演参与者：顾客情景目标：任何时候，任何地点用户通过互联网购买零食前提条件：客户已经申请了一个会员号，并且用户已经使用正确的会员号登陆起动：客户在想买零食的时候，打开电脑买零食场景：1.客户登陆零食网站2.客户输入他的会员号 3.客户输入他的密码 4.系统显示网站的零食首页信息5.客户选择零食加入购物车或者直接购买 6.客户选择完后开始点击“购买”7.系统显示出客户所购买零食的清单以及零食总价8.客户选择付款方式，然后点击“支付”9.系统提示付款成功 异常：1.会员号或者密码不正确——————参看用例：“确认用户名和密码”2.客户忘记了密码——————参看用例：“找回密码”3.还没有购物车——————参看用例：“购物车”4.支付失败——————参考用例：“支付”优先级：属于基础功能，高优先级何时可用：第X个增量，因为增量没有完全的设计，所以这里用X代替使用频率：高等频率使用方式：通过基于个人计算机的浏览器和互联网连接到零食网站次要参与者：系统管理员，客服次要参与者使用方式：1.系统管理员：基于个人计算机的系统2.客服：客服页面系统未解决的问题：1.有其他的登陆方式吗？如手机扫码登陆，手机短信登陆2.当购买人数出现高峰期时，怎样才能保证系统不崩溃？3.网络崩溃时，用户刷新后继续显示当前页面吗？ 下一节结束用例的UML图，为了应对较复杂的用例情况 补充用例的UML模型购买零食功能活动图 泳道图 参考一下blog学习：https://blog.csdn.net/fly_zxy/article/details/80939806 数据建模概念数据对象数据对象由复合信息表示。 复合信息：具有若干不同的特征或属性的事物 数据对象只封装数据 数据属性数据属性定义了数据对象的性质，有三个不同的特征 1.为数据对象实例命名 2.描述这个实例 3.建立对另一个表中的另一个实例的引用 区别于数据属性： 数据对象与数据属性的区别？car是一个数据对象，里面封装的颜色，大小，价格等是数据属性 关系有些数据对象之间是有关系的，E-R关系 12345一些常用的数据建模工具：AllFusion ERWin : https://erwin.com/?gclid=EAIaIQobChMI2-fG9ted4gIVmCCtBh0GoQBMEAAYASAAEgK8ePD_BwEER/Studio : https://www.embarcadero.com/er-studio-editionsOracle Designer : https://www.oracle.com/technetwork/developer-tools/designer/overview/index-082236.htmlVisible Analyst : http://www.visiblesystemscorp.com/Products/Analyst/index.htm 基于类的建模识别分析类分析过程，寻找名词和动词，分析类表现为以下方式之一： 1.外部实体，产生或使用基于计算机系统的信息 2.事物，问题信息域的一部分 3.偶尔事件或事件，在系统操作环境内发生 4.角色，由和系统交互的人员扮演 5.组织单元，和某个应用系统相关 6.场地，建立问题的环境和系统的整体功能 7.结构，定义了对象的类或与对象相关的类 最初找出的有用的名词或者动词只能称为潜在类，还需要考虑这些潜在类是否有以下特性 1.保留信息：只有记录潜在类的信息，系统才能正常工作，这类潜在类是有用的 2.所需服务：潜在类必须具有一组可确认的操作，这组操作能用某种方式改变类的属性值 3.多个属性：需求分析过程中，焦点应在于“主”信息，事实上，只有一个属性的类可能在设计中有用，但在分析活动阶段，最好把它作为另一个类的某个属性.意思是如果是单一属性，就没必须为这个属性创建类，而是考虑其是不是其他类的属性。 4.公共属性：可以为潜在类定义一组属性，这些属性适用于类的所有实例 5.公共操作：可以为潜在类定义一组操作，这些操作使用与类的所有实例 6.必要需求：在问题空间中出现的外部实体，和任何系统解决方案运行时所必须的生产或消费信息，几乎都被定义为需求模型中的类 描述属性属性描述了已经包含在需求模型中的类。实质上，属性是定义类以澄清类在问题空间的环境下意味着什么 可以采用一些组合项来描述数据： 用户登陆=登陆账号+登陆密码 定义操作操作定义了某个对象的行为，粗略的划分为4种： 以某种方式操作数据(例如：添加，删除，重新格式化，选择) 2.执行计算的操作 3.请求某个对象的状态的操作 4.监视某个对象发生某个控制事件的操作 类-职责-协作者建模Class-Responsibility-Collaborator,CRC卡 类： 1.实体类 2.边界类 3.控制类 职责： 1.智能系统应分布在所有类中以求最佳地满足问题的需求 2.每个职责的说明应尽可能具有普遍性 3.信息和与之相关的行为应放在同一个类中 4.某个事物的信息应局限于一个类中而不要分布在多个类中 5.适合时，职责应由相关类分享 协作： 是客户和服务器之间契约的具体实现，识别协作的方法是通过确认类本身是否实现自身的每个职责，如果不能，就需要和其他类协作 CRC的使用： CRC的使用很简单，就是先有一种主CRC卡，然后到达相应的职责时会有对应的协作者，然后再由这个协作者的类进行分析，依次类推。 关联和依赖这个关联说的有些想数据库中的E-R关系图，就一对一，一对多，多对多的关系 依赖，依赖是一个类获得另外一个类的请求后才能执行其对应的功能 分析包类似于java中的“package”]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>需求建模</tag>
        <tag>场景</tag>
        <tag>信息</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-05_理解需求]]></title>
    <url>%2F2019%2F05%2F15%2F2019-05-15-05-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文是一篇关于进行需求分析的文章 理解需求需求工程需求工程致力于不断理解需求的大量任务和技术 起始：建立基本的理解，包括对问题，谁需要解决方案，所期望解决方案的性质，与利益相关者和开发人员之间达成初步交流合作的效果。 导出 12345678910问题：系统或者产品目标是什么？想要实现什么？系统和产品如何满足业务的要求？最终系统或产品如何用于日常工作？需求导出困难的原因：范围问题理解问题易变问题 精化：集中开发一个精确的需求模型，用以说明软件的功能，特征和信息 协商：调节冲突 规格说明：图形，文档，模型，只要是易于表达意思的都行，另外这个是有模版的,模版参考Process Impact公司的需求规格说明书 确认 123456789101112需求确认检查表：需求说明清晰吗？有没有可能造成误解？需求的来源弄清楚了吗？需求的最终说明是否已经根据或对照最初来源检查过？需求是否用定量的术语界定？其它哪些需求和此需求相关？是否已经使用交叉索引矩阵或其它机制弄清楚加以说明？需求是否违背某个系统领域的约束？需求是否可测试？如果可以，能否说明检测需求的测试？对已经创建的任何系统模型，需求是否可跟踪？对整体系统/产品目标，需求是否可跟踪？规格说明的构造方式是否有助于理解，轻松引用和翻译成更技术型的工作产品？对已创建的规格说明是否建立了索引？与系统性能，行为及运行特征相关需求的说明是否清楚？哪些需求是隐含出现的？ 管理:追踪需求的变更 1234需求工具：全面的需求工具列表：https://www.volere.org/requirements-tools/需求管理工具：www-306.ibm.com/software/awdtools/reqpro/ 建立根基确认利益相关者 业务运行管理人员 产品管理人员 市场销售人员 内部和外部客户 最终用户 顾问 产品工程师 支持和维护工程师 其它人员 识别多重观点 不同的利益相关者会从他们自己的角度来寻找需求，需求工程师应该把所有人的需求进行分类整理。 协同合作如何协作 需求工程师将工作标识为公共区域，矛盾区域和不一致区域。不一致区域，也是各利益相关者需求出现冲突的区域是最具有挑战性的。 方法 使用“优先点”，利益相关者投票决定，确定需求优先点 首次提问需求导出前应该问一些与环境无关的问题，以下问题有助于识别所有对构建软件感兴趣的利益相关者： 谁是这项工作的最初请求者？ 谁将使用该方案？ 成功的解决方案能带来什么样的经济效益？ 以下问题有助于软件开发组更好的理解问题： 如何描述由成功的解决方案产生的“良好”输出的特征？ 该解决方案强调解决了什么问题？ 能向我们展示解决方案使用的商业环境吗？ 存在将影响解决方案中特殊的性能问题或约束吗？ 以下问题关注与沟通活动本身的效率，也叫“元问题” 你是回答这些问题的合适人选吗？你的回答是“正式的”吗？ 我的提问和你想解决的问题相关吗？ 我的问题是否太多了？ 还有其他人员可以提供更多的信息吗？ 还有我应该问的问题吗？ 导出需求协作收集需求步骤： 1.有了基本问题和答案，并确定了问题的范围和对解决方案的整体理解 2.拟定会议地点，会议“调解人”，采用“方案论证手段“(工作表，活动挂图，电子公告牌，聊天室或者虚拟论坛)。开发人员和客户写1～2页的“产品要求”。 3.启会前，将“产品要求”分发给所有参会者 4.参会者讨论，并制定项目对象，服务列表，约束列表，性能标准列表 1234项目对象:使用的具体对象服务列表：该项目所应该具有的服务约束列表：考虑软件所面临和会出现的意外情况，然后提前由解决方案解决性能标准列表：页面的响应速度，以及一些优先级事件 5.该专题的各个列表被提出后，生成组合列表，删除冗余项，可添加新的想法 注意点：对象和服务，这需要更多的解释，利益相关者需要为列表的条目编写规格说明。该规格要说明到对象的具体情况，例如对页面的具体要求，多高，多宽。服务要非常清晰。 保留那些还不能解决的问题 质量功能部署质量功能部署(Quality Function Deployment QFD)：将用户要求转换为软件技术需求的质量管理技术。QDF确认了三类需求： 正常需求：必须为客户实现的需求 期望需求：如果不实现，客户可能不满的一些需求 令人兴奋的需求：如果实现了，客户会非常兴奋的一些需求 用户场景用户场景就是在研究用户使用某个功能时的场景，我们必须知道用户使用某项功能的具体场景，需要什么东西，打开什么样的页面，页面上都有什么，用户是点击按钮还是做些其它动作。用户场景也叫“用例场景”。 导出工作产品工作产品包括： 1234567要求和可行性陈述系统或产品范围的界限说明参与需求导出的客户，用户和其他利益相关者的名单系统技术环境的说明需求列表(最好按功能组织)以及每个需求使用的领域限制一系列使用场景，有助于深入了解系统或产品在不同运行环境下的使用任何能够更好地定义需求的原型 所有参与需求导出的人员需要评审以上的每一个工作产品 开发用例开发用例 1.确定参与者 2.有了参与者后，才能开发用例，以下是开发用例应该回答的问题 12345678910谁是主要参与者，次要参与者？参与者的目标是什么？故事开始前有什么前提条件？参与者完成的主要工作或功能是什么？按照故事所描述的还可能需要考虑什么异常？参与者的交互中有什么可能的变化？参与者将获得，产生或改变哪些系统信息？参与者必须通知系统有关外部环境的改变吗？参与者希望从系统获取什么信息？参与者希望得知会有意料之外的变更吗？ 构建需求模型需求模型的元素基于场景的元素 从用户的视角描述系统 详情参考：https://www.cnblogs.com/xiaolongbao-lzh/p/4590897.html 基于类的元素 UML类图，第7天时具体分析 行为元素 UML状态图，第7天时具体分析 面向数据流的元素 数据流模型，第7天时具体分析 分析需求分析需求的目的是因为在特定的应用领域内某些事情在所有的项目中重复发生，这些分析模式在许多应用项目建模时可以重复使用。 协商需求协商需求要做的一系列活动 1.识别系统或子系统关键的利益相关者 2.确认利益相关者“赢”的条件 3.就利益相关者“赢”的条件进行协商，以便使其与所有涉及人的一些双赢条件一致 确认需求确认需求时应该提出以下问题： 1.每项需求都和系统或产品的整体目标一致吗？ 2.需求是真正必须的吗？ 3.每项需求都有界定且无歧义的吗？ 4.每项需求都标记了来源吗？ 5.有需求发生冲突吗？ 6.需求能保证一定可以实现吗？ 7.实现的需求是可测试的吗？ 8.需求模型有恰当的反映将要构建系统的信息，功能和行为吗？ 9.需求模型有详细分割，能逐步揭示详细的系统信息吗？ 10.每项需求模式都符合客户要求吗？]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>软件工程</tag>
        <tag>需求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-04_指导实践的原则]]></title>
    <url>%2F2019%2F05%2F13%2F2019-05-13-04-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文是一篇关于软件中如何进行实践的知道文章 指导实践的原则核心原则指导过程的原则 原则1:敏捷 原则2:每一步都关注质量 原则3:做好适应的准备 原则4:建立一个有效的团队 原则5:建立沟通和协调机制 原则6:管理变更 原则7:评估风险 原则8；创造能给别人带来价值的工作产品 指导实践的原则目标：按时交付包含满足所有利益相关者要求的功能和特性的高质量，可运行软件 原则1:分治策略，将大问题划分为小问题来解决 原则2:理解抽象的使用，将复杂元素以抽象的形式简单化 原则3:力求一致性，方便理解，给人看一眼就知道你弄的是个啥 原则4:关注信息传送，MVC设计过程中多注意 原则5:构建能展示有效模块化的软件。模块要做到有效，低耦合 原则6:寻找模式，模块可以做到让软件开发有一种共同语言 原则7:在可能的时候，用大量不同的观点描述问题及其解决方法 原则8:记住：有人将要对软件进行维护 指导每个框架活动的原则沟通原则 原则1:倾听，有不懂的要及时澄清 原则2:有准备的沟通，花时间去理解问题，调查一些专业术语，做一个议事日程 原则3:沟通活动需要有人推动，主持人 原则4:最好当面沟通 原则5:记笔记并且记录所有决定 原则6:保持通力协作 原则7:把讨论集中在限定范围内 原则8:如果有些东西很难表述清楚，采用图形表示 原则9:(a)一旦认可某件事情，转换话题,(b)如果不认可某件事情，转换话题,(c)如果某项特性或者功能不清晰，当时无法澄清，转换话题 原则10:协商不是一场竞赛或者一场游戏，协商双赢时才发挥了协商的最大价值 策划原则目的：让项目有一个好的舒服的计划进行 原则1:理解项目范围，项目的目的地 原则2:吸收利益相关者参与策划，商谈交付顺序及相关问题 原则3:要认识到计划的制定应按照迭代方式进行，迭代说增量交付 原则4:基于已知的估计 原则5:计划时考虑风险 原则6:保持脚踏实地 原则7:调整计划粒度。粒度：项目计划细节中的精细程度 原则8:制定计划确保质量 原则9:描述如何适应变化 原则10:经常跟踪并根据需要调整计划 建模原则目的：获取良好的设计方案 原则1:设计可追溯到需求模型 原则2:始终关注待建系统的架构，先架构，在构件的设计 原则3:数据设计与功能设计同等重要 原则4:必须精心设计接口 原则5:用户界面设计必须符合最终用户要求 原则6:构件设计应是功能独立的 原则7:构件之间以及构件与外部环境之间松散耦合，要低耦合 原则8:设计表述(模型)应该做到尽可能易于理解 原则9:设计应该迭代式进行 构造原则目的：1.编码生成源代码 2.测试，包括(a)单元测试，(b)集成测试，(c)确认测试，(d)验收测试 编码原则 准备原则。在写下每行代码之前，要确保： 12345理解所要解决的问题理解基本的设计原则和概念选择一种能够满足构建软件以及运行环境要求的编程语言选择一种能提供工具以简化工作的编程环境构件级编码完成后进行单元测试 编程原则。在开始编码时，要确保： 123456789遵循结构化编程方法来约束算法考虑使用结对编程选择能满足设计要求的数据结构理解软件架构并开发出与其相符的接口尽可能保持条件逻辑简单开发的嵌套循环应使其易于测试选择有意义的变量名并符合相关编码标准编写注释，湿代码具有说明性增强代码的可读性(例如：缩进和空行) 确认原则。在完成每一阶段的编码之后，要确保： 123适当进行代码走查进行单元测试并改正所发现的错误重构代码 测试原则 原则1:所有的测试都应该追溯到用户需求 原则2:测试计划应该远在测试之前就开始着手 原则3：将Pareto原则应用于软件测试。Pareto原则认为在软件测试过程中80%的错误都可以在大概20%的程序构件中找到根源 原则4:测试应该从“微观”开始，逐步转向宏观。单个程序模块–&gt;集成构件–&gt;整个系统 原则5:穷举测试是不可能的 部署原则交付，支持和反馈 原则1:客户对于软件的期望必须得到管理 原则2:完整的交付包应该经过安装和测试。交付至少是Beta测试版 原则3:技术支持必须在软件交付前就确定下来 原则4:必须为用户提供适当的说明材料 原则5；有缺陷的软件应该先改正再交付]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>软件工程</tag>
        <tag>指导实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-03_敏捷开发]]></title>
    <url>%2F2019%2F05%2F12%2F2019-05-11-03-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文是一篇关于敏捷开发的教程 敏捷开发什么是敏捷 1.自组织和跨职能团队 2.与客户/最终用户协作努力 3.适用性计划，进化发展，早期交付，持续改进，对变化作出快速且灵活的反应 continual improvement process(CIP) &amp; continuous improvement process(CI):持续改进 敏捷及变更的成本费用这个费用比着采用传统软件的好处在于后期。传统在后期需求变更中变动太大 敏捷过程3个关键假设 预测哪些需求是稳定的，哪些需求变更会非常困难 难于预测在构建验证之前应该设计到什么程度 计划并不像我们预测的那样容易 敏捷过程 采用增量的迭代方式 如何做到敏捷开发 早期和持续交付有价值的软件实现客户满意度 要欢迎不断变化的需求，即使在后期开发 经常提供工作软件（数周而不是数月），其实进步的衡量标准 —-什么是工作软件 商务人士和开发人员之间的密切，日常合作 项目围绕有动力的人进行 尽量面对面交谈 关注卓越的良好的设计 123451.更快，更小。传统的软件开发依赖于概述需求，规划，设计，构建，测试和交付等阶段。相比之下，敏捷方法试图在几个星期内部署第一个增量，并在几个月内部署整个软件。2.沟通。业务中的敏捷团队通过面对面会议每天在项目的每个阶段协同工作。这种协作和沟通确保即使条件发生变化，流程也会保持正常。3.反馈。而不是等到交付阶段来衡量成功，团队利用敏捷方法定期跟踪开发过程的成功和速度。在递送每个增量后测量速度。4.信任。敏捷团队和员工是自我组织的。他们不是遵循管理层旨在产生预期结果的规则宣言，而是了解目标并创建自己的目标。5.调整。参与者按照KIS或Keep It Simple原则不断调整和调整过程。 极限编程极限编程的权值 沟通：反复沟通，紧密交流 简明：只对即时需求做设计，不考虑长远需求 反馈：软件测试反馈，客户反馈，团队成员反馈 鼓励：有为今天做设计的纪律 尊重：尊重队友，尊重客户，尊重软件 极限编程的过程 策划:开始于聆听，倾听用户故事(需求)，放到索引卡上(CRC),如果这个用户古寺开发周期超过3个星期，进一步细分故事 设计：遵循KIS(Keep it Simple),不鼓励设计中为故事额外添加功能 编码：不直接编码，先对故事写单元测试 测试：一个是单元测试。另一个是验收测试，也是客户测试 其他敏捷过程模型12345678自适应软件开发Scrum动态系统开发方法Crystal特征驱动开发精益软件开发敏捷建模敏捷统一过程 这里只讨论Scrum Scrum：sprint计划，每日scrum，sprint审查和回顾 Product Backlog&lt;产品积压&gt;：是产品中已知所需的所有内容的有序列表。它是对产品进行任何更改的唯一要求来源。该产品负责人负责产品Backlog，包括它的内容，可用性和排序。 –什么是它的内容？需求 Sprint Backlog&lt;冲刺积压&gt;：产品积压最优先要做的 Increment:是Sprint期间完成的所有Product Backlog项目的总和 在每日Scrum期间，每个团队成员通常会回答三个问题： 123昨天我完成了什么，为团队实现我们的冲刺目标做出了贡献？我计划今天完成什么来为团队实现我们的冲刺目标做出贡献？我是否看到任何障碍可能阻止我或团队实现我们的冲刺目标？ 我对Scrum的理解:先是PM拿到需求，把需求做成Product Backlog，然后制作Sprint Backlog，Sprint Backlog是要优先解决的一部分Product Backlog。已经完成的Sprint Backlog叫Increment，当一个冲刺完成后，开始准备下一个冲刺 敏捷开发工具 OnTime:敏捷时间管理 https://www.axosoft.com/ Ideogramic UML：UML工具 Together Tool Set：工具包 https://www.microfocus.com]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>软件工程</tag>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-02_过程模型]]></title>
    <url>%2F2019%2F05%2F11%2F2019-05-10-02-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%2F</url>
    <content type="text"><![CDATA[本文是一篇关于软件中过程模型的分析 过程模型通用过程模型 沟通 策划 建模 构建 部署 过程流 描述通用过程模型在执行顺序和执行时间中的活动，动作和任务。 过程流的分类 线性过程流 迭代过程流 演化过程流 并行过程流 明确任务集 小型，相对简单的项目 1234561.执行项目的利益相关者列表2.邀请所有的利益相关者参加一个非正式会议3.征询每一个人对于软件特性和功能的需求4.讨论需求，并确定最终的需求列表5.划定需求优先级6.标出不确定领域 大型，复杂的软件工程项目 1234567891011121.制定项目的利益相关者列表2.和利益相关者的每一个成员分别单独讨论，获取所有的要求3.基于任务集2中的调查，建立初步的功能和特征列表4.安排一系列促进需求获取的会议5.组织会议6.在每次会议上建立非正式的用户场景7.根据利益相关者的反馈，进一步细化用户场景8.建立一个修正的需求列表9.使用质量功能部署技术，划分需求优先级10.将需求打包以便软件可以增量交付11.标志系统的约束和限制12.讨论系统验证方法 惯用过程模型瀑布模型 就是严格按照通用过程模型进行，沟通–&gt;策划–&gt;建模–&gt;构建–&gt;部署 使用于开发小型项目，因为大型项目需求变化快，如果后期需求发生变化，采用这种模型需求推倒重来，代价太大。 由瀑布模型演化的一个变题—-V模型 如下图，V模型下左边向下执行，然后接着右边向上执行。比着瀑布模型只是过了过程中的验证而已 增量过程模型 简单易通的增量过程模型理解 12345首先明确：每一个阶段都是一个增量第一阶段：整出一个具有核心功能的产品，交由客户评价，有问题就修改，没问题就进行下一个阶段第二阶段：开始整其它的附属功能，按功能的需求要求程度以及项目的情况划分该增量，做好后继续交给客户评价，有问题改，没问题进行下一个阶段......如此的反复解决每一个增量，最终设计出让客户满意的产品 该模型的好处，可以避免后期需求的变动而造成整个项目被大改的情况，因为每次增量结束都可以与客户交流增加和修改需求，所以需求的改动每次都是在每个增量上改动。还有个好处是，开发人员数量不够时，可以采用这种模型。 演化过程模型 先说该模型要处理的情况：需求变化太快 该模型核心：迭代 该模型主要分两类：原型模型和螺旋模型 原型开发 原型开发使用情况：1.客户只能提出软件的基本功能，但是没有详细定义功能和特性需求。2，开发人员对算法的效率，操作系统的兼容性和人机交互的形式不确定 方式：在原型的基础上不断迭代，即是对通用过程模型的不断循环 螺旋模型 主要思想依然是迭代 1234螺旋的第一圈：开发产品的规格说明接下来开发产品的原型系统每次迭代逐步完善，开发不同的软件版本即使是软件交付后，螺旋依然继续 协同模型 完全没看懂？？？？？？？ 演化模型的最终评述 市场情况：一个产品，两家都在做，你做的慢了，然后上线晚了，可以很明确的确定，也许你的产品就没有了市场，此时可以关注一下演化模型 专用过程模型 只适用于特定的软件工程方法 分类 基于构件的开发 形式化方法模型 面向方面的软件开发 统一过程(UP,Unified Precess) UP的起始阶段 UP的细化阶段 123456扩展体系结构以包括软件的五种视图：用例模型需求模型设计模型实现模型部署模型 UP的构建阶段 UP的转换阶段 UP的生产阶段 几种过程建模工具 Lgrafx Adeptia BPM Server: https://adeptia.com/ SpeedDev Suite]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>软件工程</tag>
        <tag>过程模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程-01_软件和软件工程]]></title>
    <url>%2F2019%2F05%2F09%2F2019-05-09-01-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文是一篇关于软件和软件工程的分析文章 软件和软件工程软件的本质软件主要是为了处理信息的，但我们要面临软件设计中的一些问题 1.开发周期问题/时间问题 2.开发成本问题 3.交付之前存在的Bug问题 4.维护软件的成本问题 5.维护软件的过程问题 软件定义：指令集合，数据结构，信息描述 1.首先区别与软件和硬件，软件是设计开发的，不是生产制造的 2.软件不会存在“磨损”现象，但却存在着软件维护变更现象，这会使软件出现接近线性的失效果 3.要清楚，目前市场上虽然有些软件构造模式，但用户需求始终是第一位 软件分类 系统软件 应用软件 工程/科学软件 嵌入式软件 产品线软件 Web应用软件 人工智能软件 意外效应法则：某些新科技的发明创造会给其他一些看似无关的技术领域，商业企业，公众甚至整个社会文化带来深远而出人意料的影响和作用。 WebApp的特性WebApp所具有的属性，也是软件开发必须关注的重点 网络密集性：开发网络和受限网络 并发性：高用户 无法预知的负载量：出现不同时期不同数量用户的访问 性能：可访问速度要快 可用性：需要全天候不崩溃 数据驱动：databases，数据的访问 内容敏感性：过滤敏感内容 持续演化：软件要持续更新 即时性：软件的交付推广 安全性：要有限制用户数量和用户的能力 美观性：UI 软件工程软件工程分为3层 软件过程：是基础层，这个是有框架的。主要是建立工作环境便于应用技术方法，提交工作产品(模型，文档，数据，表格等)，建立里程碑，保证质量以及正确管理变更。 软件工程方法：“如何做”的一个解决方案，主要包括：沟通，需求分析，设计建模，编程，测试和技术支持。这个有一套原则。 软件工程工具：也是计算机辅助软件工程。 软件过程软件过程 活动：实现宽泛目标，例如与利益相关者进行沟通 动作：工作产品生产过程中的一系列任务，如体系结构设计模式 任务：关注小而明确的目标，例如构建一个单元测试。 通用过程框架具备的5个活动 沟通：和用户沟通找需求 策划：策划项目执行过程中出现的所有情况。风险，进度等 建模： 构建：编码和测试 部署：交由客户评测 以上5个活动是可以迭代进行的，每次迭代都是一个软件增量 当然除了上述5种活动外，还有一些普适性活动来补充 1.风险管理 2.软件质量保证 3.技术评审 4.测量 5.软件配置管理 6.可复用管理 7.工作产品的准备和生产 软件工程实践实践者的精髓 1.理解问题(沟通和分析) 12341.谁是利益相关者？2.哪些未知？哪些数据，功能，特征和行为是解决问题必须的？3.问题可以划分吗？4.问题可以图形化描述吗？可以建立分析模型吗？ 2.计划解决方案(建模和软件设计) 12341.以前遇到过类似问题吗？能否识别一些模式？是否有一些软件已经实现了一些数据，功能，特征和行为2.能重用遇到过的解决方案所包含的元素吗？3.是否可以定义子问题？子问题可以解决吗？4.能否构建出设计模型？ 3.实施计划(代码生成) 121.算法是否验证？2.解决方案和计划是否一致？ 4.检查结果的正确性(测试和质量保证) 软件设计的一般原则 1.存在价值 2.保持简洁 3，保持愿景 4.关注使用者 5.面向未来 6.计划复用 7.认真思考]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构]]></title>
    <url>%2F2019%2F05%2F08%2F2019-05-08-01-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文是一篇关于一个算法的分值记录练习 以下代码是一个分值记录的，第一个java是一个记分对象，第二个java是实现的步骤123456789101112131415161718192021222324252627package com.hui.scoregame;public class ScoreObject &#123; private String name; private double score; public ScoreObject(String name,double score)&#123; this.name=name; this.score=score; &#125; public String getName() &#123; return name; &#125; public double getScore() &#123; return score; &#125; @Override public String toString() &#123; return "ScoreObject&#123;" + "name='" + name + '\'' + ", score=" + score + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.hui.scoregame;import java.util.Arrays;import java.util.Scanner;/*该类的作用：在一个数组里记录成绩，如果数组元素未满，就将新的元素添加进去，并排好序如果数组已经满了，就将大的元素插入，排好序 */public class ScoreGame &#123; //数组的大小 int capacity=3; ScoreObject[] arrScore=new ScoreObject[capacity]; int space; //记录此时数组中存在对象的数量 public ScoreObject[] game(String name,int score)&#123; //arrScore=new ScoreObject[capacity]; //System.out.println(Arrays.toString(arrScore)); ScoreObject scoreObject=new ScoreObject(name,score); if (arrScore[0]==null)&#123; arrScore[0]=scoreObject; &#125; //获取space,先将space重新置为0； space=0; for (int i=0;i&lt;arrScore.length;i++)&#123; if (arrScore[i]!=null)&#123; ++space; &#125; &#125; //判断数组内的元素是否已经满 if (space==capacity)&#123; //其比第一个元素小吗 if (scoreObject.getScore()&lt;arrScore[0].getScore())&#123; return arrScore; &#125;else &#123; arrScore[0]=scoreObject; //for (int i=1;i&lt;capacity;i++)&#123; int i=1; while (scoreObject.getScore()&gt;arrScore[i].getScore())&#123; //交换位置 arrScore[i-1]=arrScore[i]; //将新的数值插入 arrScore[i]=scoreObject; ++i; //防止索引越界 if (i==capacity)&#123; return arrScore; &#125; &#125; return arrScore; //&#125; &#125; &#125;else &#123; //判断新加入的分数是否比最后一个数组元素的分数大 if (arrScore[space-1].getScore()&lt;scoreObject.getScore())&#123; //如果是，就在该元素后面再添加一个元素 arrScore[space]=scoreObject; return arrScore; &#125; //如果新添加的元素比最后一个元素小 while (scoreObject.getScore()&lt;arrScore[space-1].getScore())&#123; //将最后一个元素右移 arrScore[space]=arrScore[space-1]; //将新添加的元素放到后移后剩下的空格处 arrScore[space-1]=scoreObject; //递归 --space; //如果到达了最后一个元素，直接返回，防止越界 if (space==0)&#123; return arrScore; &#125; &#125; &#125; return arrScore; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); ScoreGame scoreGame=new ScoreGame(); while(true)&#123; System.out.println("请输入一个姓名："); String name=sc.next(); System.out.println("请输入一个分数："); int score=sc.nextInt(); ScoreObject[] s = scoreGame.game(name, score); System.out.println(Arrays.toString(s)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>练习</tag>
        <tag>分值</tag>
      </tags>
  </entry>
</search>
